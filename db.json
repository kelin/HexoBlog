{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/jacman/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","path":"font/coveredbyyourgrace-webfont.eot","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/FontAwesome.otf","path":"font/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","path":"font/coveredbyyourgrace-webfont.woff","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","path":"font/coveredbyyourgrace-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","path":"font/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","path":"font/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.ttf","path":"font/fontdiao.ttf","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.eot","path":"font/fontdiao.eot","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/author.jpg","path":"img/author.jpg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nc-nd.svg","path":"img/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.woff","path":"font/fontdiao.woff","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-sa.svg","path":"img/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nc.svg","path":"img/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nd.svg","path":"img/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nc-sa.svg","path":"img/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-zero.svg","path":"img/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/favicon.ico","path":"img/favicon.ico","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by.svg","path":"img/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/jacman.jpg","path":"img/jacman.jpg","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/gallery.js","path":"js/gallery.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/logo.svg","path":"img/logo.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","path":"js/jquery.imagesloaded.min.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/scrollup.png","path":"img/scrollup.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/jquery.qrcode-0.12.0.min.js","path":"js/jquery.qrcode-0.12.0.min.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","path":"font/coveredbyyourgrace-webfont.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","path":"font/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.svg","path":"font/fontdiao.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","path":"js/jquery-2.0.3.min.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/logo.png","path":"img/logo.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","path":"font/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/banner.jpg","path":"img/banner.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/jacman/.gitignore","hash":"7d65523f2a5afb69d76824dd1dfa62a34faa3197","modified":1483708948000},{"_id":"themes/jacman/LICENSE","hash":"931516aa36c53eb7843c83d82662eb50cc3c4367","modified":1483708948000},{"_id":"themes/jacman/README_zh.md","hash":"d6014b16eaccc97dc54a7779c9e36003752410e1","modified":1483708948000},{"_id":"themes/jacman/README.md","hash":"75a5c9fbd7c9cec4d2f277042d2fee550e4936be","modified":1483708948000},{"_id":"source/.DS_Store","hash":"4c8e784ddd5f58bdcfdcffb04ddf93abe83786b9","modified":1483708467000},{"_id":"themes/jacman/_config.yml","hash":"1328f76a20c165fac27882cafa2dabaedd772228","modified":1483711208000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1483706271000},{"_id":"source/_posts/OpenGLES-matrix-usage.md","hash":"c1f6f02c784194f07980a2df693dcac39b07c4b4","modified":1481556216000},{"_id":"source/_posts/Pawn的Relevancy（关联）Checklist分析（基于虚幻3）.md","hash":"734f1a7105c2526b90fabd6d5873b2fbdb1b72b1","modified":1480163680000},{"_id":"source/_posts/SeqEvent-Touch实现原理概要.md","hash":"7ad4473b7f2155862c50d6a711453ad9c24ca6ba","modified":1480163674000},{"_id":"source/_posts/UTGame武器开火流程.md","hash":"ec01a4fa314d6b0e84d1f67befcecd6f33b05ed8","modified":1480163666000},{"_id":"source/_posts/行为树基础.md","hash":"3231dfdd1a6e3faf2baa6e549acfddf4ff5e3614","modified":1483706383000},{"_id":"source/about/index.md","hash":"ee50ba91d5c38b23e67a88cff5657bc12bfb8a82","modified":1483710442000},{"_id":"themes/jacman/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1483708948000},{"_id":"themes/jacman/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1483708879000},{"_id":"themes/jacman/.git/config","hash":"2d3ae691d19a816889480acb832a3813f5ad7605","modified":1483708948000},{"_id":"themes/jacman/.git/index","hash":"040bab55167cc98d0ae6bb45f274845bbede2147","modified":1483708948000},{"_id":"themes/jacman/languages/zh-TW.yml","hash":"61a02ba818d641579a86fcd7f5926ab1e6ab5f70","modified":1483708948000},{"_id":"themes/jacman/.git/packed-refs","hash":"facb04d8a7e4221a4b0b3dc3062a8ca586ade15d","modified":1483708948000},{"_id":"themes/jacman/languages/default.yml","hash":"eea72d6138497287c0b3f4bd93e4f6f62b7aff37","modified":1483708948000},{"_id":"themes/jacman/languages/zh-CN.yml","hash":"1f3b9d00dd4322352b0c9c82a76dc9865a616d41","modified":1483708948000},{"_id":"themes/jacman/layout/category.ejs","hash":"9b740fc33f6f028df60f0bc4312bf3ebd03aa8ea","modified":1483708948000},{"_id":"themes/jacman/layout/archive.ejs","hash":"a18842e3d719fe3ca9b977a6995f8facc75c8673","modified":1483708948000},{"_id":"themes/jacman/layout/index.ejs","hash":"75cef2172c286994af412e11ab7f4f5a0daaf1f5","modified":1483708948000},{"_id":"themes/jacman/layout/layout.ejs","hash":"5b4289a4526899809b9c2facea535367ff51ba2b","modified":1483708948000},{"_id":"themes/jacman/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1483708948000},{"_id":"themes/jacman/layout/page.ejs","hash":"bd6bbf2ea8e183bd835867ff617dc6366b56748c","modified":1483708948000},{"_id":"themes/jacman/layout/post.ejs","hash":"3114134775bdde5a83cf14feb019606fa2b2b2be","modified":1483708948000},{"_id":"themes/jacman/layout/tag.ejs","hash":"45150a2365768b6b67880193c9264ad2bb4814db","modified":1483708948000},{"_id":"themes/jacman/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1483708879000},{"_id":"themes/jacman/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1483708879000},{"_id":"themes/jacman/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1483708879000},{"_id":"themes/jacman/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1483708879000},{"_id":"themes/jacman/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1483708879000},{"_id":"themes/jacman/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1483708879000},{"_id":"themes/jacman/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1483708879000},{"_id":"themes/jacman/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1483708879000},{"_id":"themes/jacman/.git/info/exclude","hash":"bb5a85730dcf100facee799c05cc4f6affec0745","modified":1483708879000},{"_id":"themes/jacman/.git/logs/HEAD","hash":"8c9320f985df3403dc15b82aed64aa62fb55f8d2","modified":1483708948000},{"_id":"themes/jacman/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1483708879000},{"_id":"themes/jacman/layout/_partial/article.ejs","hash":"261ecacb8456f4cb972632b6a9103860fa63b9a3","modified":1483708948000},{"_id":"themes/jacman/layout/_partial/analytics.ejs","hash":"697601996220fe0a0f9cd628be67dec3c86ae2aa","modified":1483708948000},{"_id":"themes/jacman/layout/_partial/archive.ejs","hash":"2c7395e7563fe016521712a645c28a13f952d52a","modified":1483708948000},{"_id":"themes/jacman/layout/_partial/article_row.ejs","hash":"4cb855d91ece7f67b2ca0992fffa55472d0b9c93","modified":1483708948000},{"_id":"themes/jacman/layout/_partial/head.ejs","hash":"761941be4922cd3c177c8130296b909bf7db5c09","modified":1483708948000},{"_id":"themes/jacman/layout/_partial/footer.ejs","hash":"5f80bf6c6ddcf8c28c4599cd1540b14b25d54f18","modified":1483708948000},{"_id":"themes/jacman/layout/_partial/header.ejs","hash":"18515612344ff048b9372b91b7eef6f3b143801f","modified":1483708948000},{"_id":"themes/jacman/layout/_partial/categories.ejs","hash":"8a52d0344d5bce1925cf586ed73c11192925209b","modified":1483708948000},{"_id":"themes/jacman/layout/_partial/pagination.ejs","hash":"6146ac37dfb4f8613090bc52b3fc8cfa911a186a","modified":1483708948000},{"_id":"themes/jacman/layout/_partial/after_footer.ejs","hash":"c703b0c25139b8a5f8f9d24a334a07905e2b7987","modified":1483708948000},{"_id":"themes/jacman/layout/_partial/sidebar.ejs","hash":"c4f527fff0070fbe65919053a16224412317f40d","modified":1483708948000},{"_id":"themes/jacman/layout/_partial/mathjax.ejs","hash":"d42994ac696f52ba99c1cbac382cd76d5b04a3e8","modified":1483708948000},{"_id":"themes/jacman/layout/_partial/totop.ejs","hash":"bea5bb7cb9350b8af7d97a8d223af63a5b30ab78","modified":1483708948000},{"_id":"themes/jacman/layout/_widget/archive.ejs","hash":"39ea6b7888406fbd1b4cf236ebd718e881493374","modified":1483708948000},{"_id":"themes/jacman/layout/_partial/tags.ejs","hash":"b33b2b5d08f1d53a8de25a95f660f7f1cea7b3cb","modified":1483708948000},{"_id":"themes/jacman/layout/_partial/tinysou_search.ejs","hash":"06ecddc8a9d40b480fe2e958af1dab857a9d5441","modified":1483708948000},{"_id":"themes/jacman/layout/_widget/github-card.ejs","hash":"5c759b6ea214bac56a393247de27e67ce73fb33f","modified":1483708948000},{"_id":"themes/jacman/layout/_widget/douban.ejs","hash":"e3820c36169e88663e6c9177666b2904c1ce47e6","modified":1483708948000},{"_id":"themes/jacman/layout/_widget/rss.ejs","hash":"0a4b5f2a2e36a1d504fe2e7c6c8372cbb4628aab","modified":1483708948000},{"_id":"themes/jacman/layout/_widget/links.ejs","hash":"e49868063439c2092cdf9a8ec82cc295b0e42f66","modified":1483708948000},{"_id":"themes/jacman/layout/_widget/tag.ejs","hash":"7e82ad9c916b9ce871b2f65ce8f283c5ba47947b","modified":1483708948000},{"_id":"themes/jacman/layout/_widget/category.ejs","hash":"c1fae96b5053da021bcc04ab2ce5c2c8d30de8a2","modified":1483708948000},{"_id":"themes/jacman/layout/_widget/tagcloud.ejs","hash":"10a1001189d5c28ce6d42494563b9637c302b454","modified":1483708948000},{"_id":"themes/jacman/layout/_widget/weibo.ejs","hash":"a31c2b223d0feb2a227e203cac9e5d13b7d328a8","modified":1483708948000},{"_id":"themes/jacman/layout/_partial/search.ejs","hash":"1083824a6c6c3df02767f2f3b727aee78ebb76ec","modified":1483708948000},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1483708948000},{"_id":"themes/jacman/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1483708948000},{"_id":"themes/jacman/source/css/style.styl","hash":"a0a45af186a72ae68979bf26f2a5d0d2303189ca","modified":1483708948000},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1483708948000},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1483708948000},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1483708948000},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1483708948000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1483708948000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1483708948000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1483708948000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","hash":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1483708948000},{"_id":"themes/jacman/source/font/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1483708948000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","hash":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1483708948000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","hash":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1483708948000},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1483708948000},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1483708948000},{"_id":"themes/jacman/source/font/fontdiao.ttf","hash":"ee9fd7be2493c9bf6d2841044e69a0830d9d3fab","modified":1483708948000},{"_id":"themes/jacman/source/font/fontdiao.eot","hash":"9544a0d7ba208989302bc4da5a184faeb0e883c9","modified":1483708948000},{"_id":"themes/jacman/source/img/author.jpg","hash":"2a292e681b4c6c975eec9c8c356d99647a465542","modified":1483708948000},{"_id":"themes/jacman/source/img/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1483708948000},{"_id":"themes/jacman/source/font/fontdiao.woff","hash":"71f54eb6e98aa28cafeb04aab71c0e5b349ea89f","modified":1483708948000},{"_id":"themes/jacman/source/img/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1483708948000},{"_id":"themes/jacman/source/img/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1483708948000},{"_id":"themes/jacman/source/img/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1483708948000},{"_id":"themes/jacman/source/img/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1483708948000},{"_id":"themes/jacman/source/img/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1483708948000},{"_id":"themes/jacman/source/img/favicon.ico","hash":"2d22a3e0c7905a894e832c831dd91c29c209c7a5","modified":1483708948000},{"_id":"themes/jacman/source/img/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1483708948000},{"_id":"themes/jacman/source/img/jacman.jpg","hash":"0ba14a4a5e3be012826fc713c33479912126d34e","modified":1483708948000},{"_id":"themes/jacman/source/js/gallery.js","hash":"f8a4ba7fb8349cca374a3c69fff9b2bf21f742ed","modified":1483708948000},{"_id":"themes/jacman/source/img/logo.svg","hash":"9ae38f7225c38624faeb7b74996efa9de7bf065b","modified":1483708948000},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","hash":"4109837b1f6477bacc6b095a863b1b95b1b3693f","modified":1483708948000},{"_id":"themes/jacman/source/img/scrollup.png","hash":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1483708948000},{"_id":"themes/jacman/source/js/jquery.qrcode-0.12.0.min.js","hash":"57c3987166a26415a71292162690e82c21e315ad","modified":1483708948000},{"_id":"themes/jacman/source/js/totop.js","hash":"cad23c5ea7163d1e5c05a0fd3ef9233469da10cb","modified":1483708948000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","hash":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53","modified":1483708948000},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1483708948000},{"_id":"themes/jacman/source/font/fontdiao.svg","hash":"334a94e6a66a8b089be7315d876bec93efe38d2b","modified":1483708948000},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","hash":"a0ae3697b0ab8c0e8bd3186c80db42abd6d97a8d","modified":1483708948000},{"_id":"themes/jacman/source/img/logo.png","hash":"fd08d12d1fa147cf894e8f8327e38f1758de32ed","modified":1483708948000},{"_id":"themes/jacman/.git/refs/heads/master","hash":"51d4013e66aa8b536ba9b382ed64385114d32d9a","modified":1483708948000},{"_id":"themes/jacman/.git/objects/pack/pack-74fbd74b9876cf352f0b33b4a0079e6d77a91d08.idx","hash":"9bb1026a7e2aa5fdd88f562892bce116d1995ad5","modified":1483708948000},{"_id":"themes/jacman/layout/_partial/post/catetags.ejs","hash":"0e37bababc8f4659f5b59a552a946b46d89e4158","modified":1483708948000},{"_id":"themes/jacman/layout/_partial/post/comment.ejs","hash":"c88bc8f5805173920a5fdd7e9234a850e3d8e151","modified":1483708948000},{"_id":"themes/jacman/layout/_partial/post/footer.ejs","hash":"b12ec08a5845a3d8c01257614f1dfead879c87d2","modified":1483708948000},{"_id":"themes/jacman/layout/_partial/post/header.ejs","hash":"36a705942b691abe0d643ea8afa339981b32f6f2","modified":1483708948000},{"_id":"themes/jacman/layout/_partial/post/gallery.ejs","hash":"fafc2501d7e65983b0f5c2b58151ca12e57c0574","modified":1483708948000},{"_id":"themes/jacman/layout/_partial/post/jiathis.ejs","hash":"d7f5960039ac74924559ab6ba03c64457b8f0966","modified":1483708948000},{"_id":"themes/jacman/layout/_partial/post/article.ejs","hash":"b09e3acea7076e1f01dfe0c2295e19951ea09437","modified":1483708948000},{"_id":"themes/jacman/layout/_partial/post/pagination.ejs","hash":"7de9c07a4c968429a8088c31a28b7f3a993ded1b","modified":1483708948000},{"_id":"themes/jacman/source/css/_base/font.styl","hash":"c8a0faf43b08e37ad07a5669db76d595da966159","modified":1483708948000},{"_id":"themes/jacman/source/css/_base/public.styl","hash":"f016180726019927b9a835ed01e04d153f27a149","modified":1483708948000},{"_id":"themes/jacman/source/css/_partial/aside.styl","hash":"506fde1d67ce750452cbe84bee01a19c7d027c5e","modified":1483708948000},{"_id":"themes/jacman/source/css/_base/variable.styl","hash":"cb652eb83c28a208743fabab92de896f8b7cbf7b","modified":1483708948000},{"_id":"themes/jacman/source/css/_partial/duoshuo.styl","hash":"e85f1192283f043115c272a9deb3cb6ced793990","modified":1483708948000},{"_id":"themes/jacman/source/css/_partial/article.styl","hash":"c69641b4a34a8c62986b335414413dbde26de25e","modified":1483708948000},{"_id":"themes/jacman/source/css/_partial/footer.styl","hash":"1911613a19b605a58f801c21b03b5d4c83b90f9c","modified":1483708948000},{"_id":"themes/jacman/source/css/_partial/gallery.styl","hash":"7246809f4ce3166ec1b259bf475cae1a48e29aad","modified":1483708948000},{"_id":"themes/jacman/source/css/_partial/header.styl","hash":"5121ceb712be3f2dde98b8b6e589b546e19eab8f","modified":1483708948000},{"_id":"themes/jacman/source/css/_partial/totop.styl","hash":"96363d7c5aaed5f649667fc0752a62620a67e872","modified":1483708948000},{"_id":"themes/jacman/source/css/_partial/helper.styl","hash":"1136600932b97534b88465bf05ef313630b2de3d","modified":1483708948000},{"_id":"themes/jacman/source/css/_partial/index.styl","hash":"a72ff14effd276015264f870f47ed8f8413bf5d3","modified":1483708948000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1483708948000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1483708948000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1483708948000},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1483708948000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1483708948000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1483708948000},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1483708948000},{"_id":"themes/jacman/source/img/banner.jpg","hash":"5104860c4f8b2e84ef734ba6c37fe7a288bf0d74","modified":1483708948000},{"_id":"themes/jacman/.git/logs/refs/heads/master","hash":"8c9320f985df3403dc15b82aed64aa62fb55f8d2","modified":1483708948000},{"_id":"themes/jacman/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1483708948000},{"_id":"themes/jacman/source/css/_base/highlight/theme.styl","hash":"e3a59bd427ba37a54ead9eeba9a5356b3f720a48","modified":1483708948000},{"_id":"themes/jacman/source/css/_base/highlight/highlight.styl","hash":"91b62bfc58390b0d5db782a75be6965ee3665eb3","modified":1483708948000},{"_id":"themes/jacman/.git/logs/refs/remotes/origin/HEAD","hash":"8c9320f985df3403dc15b82aed64aa62fb55f8d2","modified":1483708948000},{"_id":"themes/jacman/.git/objects/pack/pack-74fbd74b9876cf352f0b33b4a0079e6d77a91d08.pack","hash":"b5b34de021d1f31cde7176bf4a1b60b40edd70f9","modified":1483708948000},{"_id":"public/about/index.html","hash":"ec2af72a8fc3b9364e74331e951c88d14cc9c868","modified":1483711762124},{"_id":"public/categories/OpenGL-ES/index.html","hash":"baace184c458414295eb6785a072db9e2987b312","modified":1483711762124},{"_id":"public/archives/index.html","hash":"750ea2120c6df47aa7b23b9a5a59e610eba7202d","modified":1483711762278},{"_id":"public/archives/2016/index.html","hash":"abf5d47e0c746206dfd7a7a8e27ad9d263c7342a","modified":1483711762284},{"_id":"public/archives/2016/11/index.html","hash":"64f76ae6cbea5240084e10b5ffc881b2150aeda5","modified":1483711762284},{"_id":"public/index.html","hash":"98482e227951d65ed4d8901c876e7c968ca0e55e","modified":1483711762286},{"_id":"public/tags/OpenGL-ES/index.html","hash":"b189dafc9814d34542e559c577c9ef915abe2e32","modified":1483711762286},{"_id":"public/2016/11/21/OpenGLES-matrix-usage/index.html","hash":"b399218e008172b722eecadc6bb34804b97301ca","modified":1483711762286},{"_id":"public/2016/12/08/行为树基础/index.html","hash":"1edb71f46adf27b0efc55f05f210bff7ceab892d","modified":1483711762296},{"_id":"public/categories/虚幻3/index.html","hash":"237dc900d36a529c3d229443abf1730248ae499e","modified":1483711762296},{"_id":"public/categories/Behavior-Tree/index.html","hash":"f00fe7904e8eb643267e7bb012c24515de9dbea8","modified":1483711762296},{"_id":"public/archives/2016/12/index.html","hash":"2845ff62491f45656679a903c78454bc88ceb434","modified":1483711762296},{"_id":"public/2016/11/26/Pawn的Relevancy（关联）Checklist分析（基于虚幻3）/index.html","hash":"95b14c1336fe55209416cdcdf6869b47e1b6753a","modified":1483711762296},{"_id":"public/2016/11/26/SeqEvent-Touch实现原理概要/index.html","hash":"37be09a4d0b2f84e0a58ec46869e1fbd31bf886d","modified":1483711762296},{"_id":"public/2016/11/26/UTGame武器开火流程/index.html","hash":"a5e97887fec96d8283d22dbf28fe919fbaedb71f","modified":1483711762296},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1483711762304},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1483711762304},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1483711762305},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1483711762305},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1483711762305},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1483711762305},{"_id":"public/font/coveredbyyourgrace-webfont.eot","hash":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1483711762305},{"_id":"public/font/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1483711762305},{"_id":"public/font/coveredbyyourgrace-webfont.woff","hash":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1483711762306},{"_id":"public/font/coveredbyyourgrace-webfont.ttf","hash":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1483711762306},{"_id":"public/font/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1483711762306},{"_id":"public/font/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1483711762306},{"_id":"public/font/fontdiao.ttf","hash":"ee9fd7be2493c9bf6d2841044e69a0830d9d3fab","modified":1483711762306},{"_id":"public/font/fontdiao.eot","hash":"9544a0d7ba208989302bc4da5a184faeb0e883c9","modified":1483711762306},{"_id":"public/font/fontdiao.woff","hash":"71f54eb6e98aa28cafeb04aab71c0e5b349ea89f","modified":1483711762306},{"_id":"public/img/author.jpg","hash":"2a292e681b4c6c975eec9c8c356d99647a465542","modified":1483711762306},{"_id":"public/img/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1483711762306},{"_id":"public/img/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1483711762306},{"_id":"public/img/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1483711762306},{"_id":"public/img/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1483711762306},{"_id":"public/img/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1483711762306},{"_id":"public/img/favicon.ico","hash":"2d22a3e0c7905a894e832c831dd91c29c209c7a5","modified":1483711762306},{"_id":"public/img/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1483711762306},{"_id":"public/img/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1483711762306},{"_id":"public/img/jacman.jpg","hash":"0ba14a4a5e3be012826fc713c33479912126d34e","modified":1483711762306},{"_id":"public/img/logo.svg","hash":"9ae38f7225c38624faeb7b74996efa9de7bf065b","modified":1483711762306},{"_id":"public/img/scrollup.png","hash":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1483711762306},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1483711762306},{"_id":"public/font/coveredbyyourgrace-webfont.svg","hash":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53","modified":1483711763471},{"_id":"public/font/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1483711763476},{"_id":"public/font/fontdiao.svg","hash":"334a94e6a66a8b089be7315d876bec93efe38d2b","modified":1483711763480},{"_id":"public/img/logo.png","hash":"fd08d12d1fa147cf894e8f8327e38f1758de32ed","modified":1483711763480},{"_id":"public/js/totop.js","hash":"cad23c5ea7163d1e5c05a0fd3ef9233469da10cb","modified":1483711763484},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1483711763484},{"_id":"public/js/gallery.js","hash":"f8a4ba7fb8349cca374a3c69fff9b2bf21f742ed","modified":1483711763484},{"_id":"public/js/jquery.imagesloaded.min.js","hash":"4109837b1f6477bacc6b095a863b1b95b1b3693f","modified":1483711763484},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1483711763484},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1483711763484},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1483711763484},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1483711763484},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1483711763484},{"_id":"public/css/style.css","hash":"1737965b2ad2e4999c93bfa7657bdfc9990675f3","modified":1483711763484},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1483711763484},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1483711763484},{"_id":"public/js/jquery.qrcode-0.12.0.min.js","hash":"57c3987166a26415a71292162690e82c21e315ad","modified":1483711763485},{"_id":"public/js/jquery-2.0.3.min.js","hash":"a0ae3697b0ab8c0e8bd3186c80db42abd6d97a8d","modified":1483711763485},{"_id":"public/font/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1483711763489},{"_id":"public/img/banner.jpg","hash":"5104860c4f8b2e84ef734ba6c37fe7a288bf0d74","modified":1483711763489}],"Category":[{"name":"OpenGL ES","_id":"cixlvoa2m0003jtu3dxvltl98"},{"name":"虚幻3","_id":"cixlvoa2y0008jtu3v378hnww"},{"name":"Behavior Tree","_id":"cixlvoa31000djtu3kp1vrtdx"}],"Data":[],"Page":[{"title":"about","date":"2016-11-25T15:39:28.000Z","_content":"Building...","source":"about/index.md","raw":"---\ntitle: about\ndate: 2016-11-25 23:39:28\n---\nBuilding...","updated":"2017-01-06T13:47:22.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cixlvoa2j0001jtu3xr7k7jvv","content":"<p>Building…</p>\n","excerpt":"","more":"<p>Building…</p>\n"}],"Post":[{"title":"矩阵的应用","date":"2016-11-21T15:22:31.000Z","mathjax":true,"_content":"\n# 矩阵的应用\n## 模型矩阵\n模型矩阵是相对于世界坐标系的，包含一系列平移、缩放、旋转的变换信息的矩阵。它与点的位置没有任何关系。基本的模型矩阵有平移矩阵、缩放矩阵、旋转矩阵，模型矩阵左乘模型矩阵，还是模型矩阵。点坐标左乘模型矩阵就能得到最终变换的坐标。因此，多个顶点能共用同一个模型矩阵，一般一个模型里的所有顶点都共用一个模型矩阵。\n### 平移矩阵\n$$\n \\left[\n \\begin{matrix}\n   1 & 0 & 0 & X_t \\\\\\\\\n   0 & 1 & 0 & Y_t \\\\\\\\\n   0 & 0 & 1 & Z_t \\\\\\\\\n   0 & 0 & 0 & 1\n  \\end{matrix}\n  \\right]\n$$\n例如：Vec(2,2,0) 沿着X轴平移3，沿着Y轴平移3，则：\n$$\n\\left[\n    \\begin{matrix}\n        1 & 0 & 0 & 3 \\\\\\\\\n        0 & 1 & 0 & 3 \\\\\\\\\n        0 & 0 & 1 & 0 \\\\\\\\\n        0 & 0 & 0 & 1\n    \\end{matrix}\n\\right]\n\\left[\n    \\begin{matrix}\n        2 \\\\\\\\\n        2 \\\\\\\\\n        0 \\\\\\\\\n        1\n    \\end{matrix}\n\\right]\n=\n\\left[\n    \\begin{matrix}\n        5 \\\\\\\\\n        5 \\\\\\\\\n        0 \\\\\\\\\n        1\n    \\end{matrix}\n\\right]\n$$\n\n###缩放矩阵\n$$\n\\begin{bmatrix}\n    S_x & 0 & 0 & 0 \\\\\\\\\n    0 & S_y & 0 & 0 \\\\\\\\\n    0 & 0 & S_z & 0 \\\\\\\\\n    0 & 0 & 0 & 1\n\\end{bmatrix}\n$$\n\n### 旋转矩阵\n#### 点绕z轴旋转：\n（左手坐标系，其中θ是Yaw角）：\n$$\n\\begin{bmatrix}\n    \\cos\\theta & \\sin\\theta & 0 & 0 \\\\\\\\\n    -\\sin\\theta & \\cos\\theta & 0 & 0 \\\\\\\\\n    0 & 0 & 1 & 0 \\\\\\\\\n    0 & 0 & 0 & 1\n\\end{bmatrix}\n$$\n（右手坐标系，其中θ是Yaw角）：\n$$\n\\begin{bmatrix}\n    \\cos\\theta & -\\sin\\theta & 0 & 0 \\\\\\\\\n    \\sin\\theta & \\cos\\theta & 0 & 0 \\\\\\\\\n    0 & 0 & 1 & 0 \\\\\\\\\n    0 & 0 & 0 & 1\n\\end{bmatrix}\n$$\n\n#### 点绕x轴旋转：\n（左手坐标系，其中θ是roll角）：\n$$\\begin{bmatrix}\n    1 & 0 & 0 & 0 \\\\\\\\ \n    0 & \\cos\\theta & \\sin\\theta & 0 \\\\\\\\ \n    0 & -\\sin\\theta & \\cos\\theta & 0 \\\\\\\\\n    0 & 0 & 0 & 1\n\\end{bmatrix}$$\n（右手坐标系，其中θ是roll角）：\n$$\\begin{bmatrix}\n    1 & 0 & 0 & 0 \\\\\\\\ \n    0 & \\cos\\theta & -\\sin\\theta & 0 \\\\\\\\ \n    0 & \\sin\\theta & \\cos\\theta & 0 \\\\\\\\\n    0 & 0 & 0 & 1\n\\end{bmatrix}$$\n\n#### 点绕y轴旋转\n（左手坐标系，其中θ是pitch角）：\n$$\\begin{bmatrix}\n    \\cos\\theta & 0 & -\\sin\\theta & 0\\\\\\\\\n    0 & 1 & 0 & 0\\\\\\\\\n    \\sin\\theta & 0 & \\cos\\theta & 0 \\\\\\\\\n    0 & 0 & 0 & 1\n\\end{bmatrix}$$\n（右手坐标系，其中θ是pitch角）\n$$\\begin{bmatrix}\n    \\cos\\theta & 0 & \\sin\\theta & 0\\\\\\\\\n    0 & 1 & 0 & 0\\\\\\\\\n    -\\sin\\theta & 0 & \\cos\\theta & 0 \\\\\\\\\n    0 & 0 & 0 & 1\n\\end{bmatrix}$$\n\n***\n## 视图矩阵\n概念：视图矩阵是本地坐标系在世界坐标系中的变换的模型矩阵的逆矩阵，因此视图矩阵也是可以分为平移、缩放、旋转的。\n好吧，说点人话，一个摄像机，在世界坐标系中，经过模型矩阵*M1*（模型变换），从原点沿着X轴正方向前进10单位。这时候，摄像机的视图矩阵为*M2*，而且*M2*是*M1*的逆矩阵。*M2*的几何含义：假设摄像机一直原地不动，而是这个世界以*M2*为模型矩阵进行变换，往后移动了10个单位，也就是摄像机在世界坐标系下的平移、缩放、旋转等变换的反向过程。\n作用：获得相对坐标（本地坐标）。\n将视图矩阵左乘一个物体最终的模型矩阵，得到的矩阵就是所谓的“模型视图矩阵”。“模型视图矩阵”左乘一个世界坐标系下的坐标点，得到的是相对于本地坐标系的坐标点。\n举个例子：一个摄像机和一个物体，一起同样的速度和方向，从世界坐标系的原点沿着X轴的正方形移动了10个单位。摄像机的视图矩阵左乘物体的模型矩阵（模型视图矩阵）表示的含义可以理解为：世界往X轴的负方向移动了10个单位，然后在沿x轴正方向移动10个单位，因此任何一个坐标点乘以这个模型视图矩阵，都不会发生变化，明显，摄像机和物体相对静止的。\n\n\n***\n## 投影矩阵\n投影矩阵就是把三维空间投影到二维的空间。方式有正交和透视两种。\n### 正交投影矩阵\n- 作用：正交投影矩阵可以把虚拟坐标转换回归一化设备坐标（正交投影矩阵乘以虚拟坐标）。\n- 归一化设备坐标：在OpenGL里，一切物体都要映射到X、Y轴和Z轴的[-1,1]范围内，这个范围内的坐标被称为归一化设备坐标，其独立于屏幕实际的尺寸。归一化设备坐标假定坐标空间是个正方形。\n- 虚拟坐标空间：为了让屏幕形状考虑进来，把宽和高中较小的一个的范围定在[-1,1]内，另外一个根据屏幕尺寸比例调整为较大的范围。\n\n正交投影矩阵如下：\n$$\n \\left[\n \\begin{matrix}\n   \\frac{2}{right-left} & 0 & 0 & -\\frac{right+left}{right-left} \\\\\\\\\n   0 & \\frac{2}{top-bottom} & 0 & -\\frac{top+bottom}{top-bottom} \\\\\\\\\n   0 & 0 &  -\\frac{2}{far-near} & -\\frac{far+near}{far-near} \\\\\\\\\n   0 & 0 & 0 & 1\n  \\end{matrix}\n  \\right]\n$$\n注意：使用的是左手坐标系还是右手坐标系，这两者的Z轴是相反的。\n其实在一个顶点着色器的顶点位置(gl_Position)变为归一化设备坐标前，还会做透视除法（xyz都除以w）。\n\n### 透视投影矩阵\n透视投影矩阵最大的作用是产生正确的w值。w值可以理解为距离，w值越大，离中心点越近。\n\n透视投影矩阵\n$$\n \\left[\n \\begin{matrix}\n   \\frac{α}{width/height} & 0 & 0 & 0 \\\\\\\\\n   0 & α & 0 & 0 \\\\\\\\\n   0 & 0 & -\\frac{far+near}{far-near} & -\\frac{2\\*far\\*near}{far-near} \\\\\\\\\n   0 & 0 & -1 & 0\n  \\end{matrix}\n  \\right]\n$$\n其中α是焦距:\n$$α = \\frac {1} {tan(FOV/2)}$$\nFOV是相机的垂直视角，而不是水平视角\nwidth:屏幕宽度\nheight:屏幕高度\nfar: 到远处平面的距离（>0 && > near）\nnear: 到近处平面的距离（>0）\n\n***\n## 虚拟世界的顶点画到在屏幕上经过的变换过程\n变换后的坐标 = 视口矩阵 x 投影矩阵 x 视图矩阵 x 模型矩阵 x 模型点坐标","source":"_posts/OpenGLES-matrix-usage.md","raw":"---\ntitle: 矩阵的应用\ndate: 2016-11-21 23:22:31\ntags: OpenGL ES\ncategories: OpenGL ES\nmathjax: true\n---\n\n# 矩阵的应用\n## 模型矩阵\n模型矩阵是相对于世界坐标系的，包含一系列平移、缩放、旋转的变换信息的矩阵。它与点的位置没有任何关系。基本的模型矩阵有平移矩阵、缩放矩阵、旋转矩阵，模型矩阵左乘模型矩阵，还是模型矩阵。点坐标左乘模型矩阵就能得到最终变换的坐标。因此，多个顶点能共用同一个模型矩阵，一般一个模型里的所有顶点都共用一个模型矩阵。\n### 平移矩阵\n$$\n \\left[\n \\begin{matrix}\n   1 & 0 & 0 & X_t \\\\\\\\\n   0 & 1 & 0 & Y_t \\\\\\\\\n   0 & 0 & 1 & Z_t \\\\\\\\\n   0 & 0 & 0 & 1\n  \\end{matrix}\n  \\right]\n$$\n例如：Vec(2,2,0) 沿着X轴平移3，沿着Y轴平移3，则：\n$$\n\\left[\n    \\begin{matrix}\n        1 & 0 & 0 & 3 \\\\\\\\\n        0 & 1 & 0 & 3 \\\\\\\\\n        0 & 0 & 1 & 0 \\\\\\\\\n        0 & 0 & 0 & 1\n    \\end{matrix}\n\\right]\n\\left[\n    \\begin{matrix}\n        2 \\\\\\\\\n        2 \\\\\\\\\n        0 \\\\\\\\\n        1\n    \\end{matrix}\n\\right]\n=\n\\left[\n    \\begin{matrix}\n        5 \\\\\\\\\n        5 \\\\\\\\\n        0 \\\\\\\\\n        1\n    \\end{matrix}\n\\right]\n$$\n\n###缩放矩阵\n$$\n\\begin{bmatrix}\n    S_x & 0 & 0 & 0 \\\\\\\\\n    0 & S_y & 0 & 0 \\\\\\\\\n    0 & 0 & S_z & 0 \\\\\\\\\n    0 & 0 & 0 & 1\n\\end{bmatrix}\n$$\n\n### 旋转矩阵\n#### 点绕z轴旋转：\n（左手坐标系，其中θ是Yaw角）：\n$$\n\\begin{bmatrix}\n    \\cos\\theta & \\sin\\theta & 0 & 0 \\\\\\\\\n    -\\sin\\theta & \\cos\\theta & 0 & 0 \\\\\\\\\n    0 & 0 & 1 & 0 \\\\\\\\\n    0 & 0 & 0 & 1\n\\end{bmatrix}\n$$\n（右手坐标系，其中θ是Yaw角）：\n$$\n\\begin{bmatrix}\n    \\cos\\theta & -\\sin\\theta & 0 & 0 \\\\\\\\\n    \\sin\\theta & \\cos\\theta & 0 & 0 \\\\\\\\\n    0 & 0 & 1 & 0 \\\\\\\\\n    0 & 0 & 0 & 1\n\\end{bmatrix}\n$$\n\n#### 点绕x轴旋转：\n（左手坐标系，其中θ是roll角）：\n$$\\begin{bmatrix}\n    1 & 0 & 0 & 0 \\\\\\\\ \n    0 & \\cos\\theta & \\sin\\theta & 0 \\\\\\\\ \n    0 & -\\sin\\theta & \\cos\\theta & 0 \\\\\\\\\n    0 & 0 & 0 & 1\n\\end{bmatrix}$$\n（右手坐标系，其中θ是roll角）：\n$$\\begin{bmatrix}\n    1 & 0 & 0 & 0 \\\\\\\\ \n    0 & \\cos\\theta & -\\sin\\theta & 0 \\\\\\\\ \n    0 & \\sin\\theta & \\cos\\theta & 0 \\\\\\\\\n    0 & 0 & 0 & 1\n\\end{bmatrix}$$\n\n#### 点绕y轴旋转\n（左手坐标系，其中θ是pitch角）：\n$$\\begin{bmatrix}\n    \\cos\\theta & 0 & -\\sin\\theta & 0\\\\\\\\\n    0 & 1 & 0 & 0\\\\\\\\\n    \\sin\\theta & 0 & \\cos\\theta & 0 \\\\\\\\\n    0 & 0 & 0 & 1\n\\end{bmatrix}$$\n（右手坐标系，其中θ是pitch角）\n$$\\begin{bmatrix}\n    \\cos\\theta & 0 & \\sin\\theta & 0\\\\\\\\\n    0 & 1 & 0 & 0\\\\\\\\\n    -\\sin\\theta & 0 & \\cos\\theta & 0 \\\\\\\\\n    0 & 0 & 0 & 1\n\\end{bmatrix}$$\n\n***\n## 视图矩阵\n概念：视图矩阵是本地坐标系在世界坐标系中的变换的模型矩阵的逆矩阵，因此视图矩阵也是可以分为平移、缩放、旋转的。\n好吧，说点人话，一个摄像机，在世界坐标系中，经过模型矩阵*M1*（模型变换），从原点沿着X轴正方向前进10单位。这时候，摄像机的视图矩阵为*M2*，而且*M2*是*M1*的逆矩阵。*M2*的几何含义：假设摄像机一直原地不动，而是这个世界以*M2*为模型矩阵进行变换，往后移动了10个单位，也就是摄像机在世界坐标系下的平移、缩放、旋转等变换的反向过程。\n作用：获得相对坐标（本地坐标）。\n将视图矩阵左乘一个物体最终的模型矩阵，得到的矩阵就是所谓的“模型视图矩阵”。“模型视图矩阵”左乘一个世界坐标系下的坐标点，得到的是相对于本地坐标系的坐标点。\n举个例子：一个摄像机和一个物体，一起同样的速度和方向，从世界坐标系的原点沿着X轴的正方形移动了10个单位。摄像机的视图矩阵左乘物体的模型矩阵（模型视图矩阵）表示的含义可以理解为：世界往X轴的负方向移动了10个单位，然后在沿x轴正方向移动10个单位，因此任何一个坐标点乘以这个模型视图矩阵，都不会发生变化，明显，摄像机和物体相对静止的。\n\n\n***\n## 投影矩阵\n投影矩阵就是把三维空间投影到二维的空间。方式有正交和透视两种。\n### 正交投影矩阵\n- 作用：正交投影矩阵可以把虚拟坐标转换回归一化设备坐标（正交投影矩阵乘以虚拟坐标）。\n- 归一化设备坐标：在OpenGL里，一切物体都要映射到X、Y轴和Z轴的[-1,1]范围内，这个范围内的坐标被称为归一化设备坐标，其独立于屏幕实际的尺寸。归一化设备坐标假定坐标空间是个正方形。\n- 虚拟坐标空间：为了让屏幕形状考虑进来，把宽和高中较小的一个的范围定在[-1,1]内，另外一个根据屏幕尺寸比例调整为较大的范围。\n\n正交投影矩阵如下：\n$$\n \\left[\n \\begin{matrix}\n   \\frac{2}{right-left} & 0 & 0 & -\\frac{right+left}{right-left} \\\\\\\\\n   0 & \\frac{2}{top-bottom} & 0 & -\\frac{top+bottom}{top-bottom} \\\\\\\\\n   0 & 0 &  -\\frac{2}{far-near} & -\\frac{far+near}{far-near} \\\\\\\\\n   0 & 0 & 0 & 1\n  \\end{matrix}\n  \\right]\n$$\n注意：使用的是左手坐标系还是右手坐标系，这两者的Z轴是相反的。\n其实在一个顶点着色器的顶点位置(gl_Position)变为归一化设备坐标前，还会做透视除法（xyz都除以w）。\n\n### 透视投影矩阵\n透视投影矩阵最大的作用是产生正确的w值。w值可以理解为距离，w值越大，离中心点越近。\n\n透视投影矩阵\n$$\n \\left[\n \\begin{matrix}\n   \\frac{α}{width/height} & 0 & 0 & 0 \\\\\\\\\n   0 & α & 0 & 0 \\\\\\\\\n   0 & 0 & -\\frac{far+near}{far-near} & -\\frac{2\\*far\\*near}{far-near} \\\\\\\\\n   0 & 0 & -1 & 0\n  \\end{matrix}\n  \\right]\n$$\n其中α是焦距:\n$$α = \\frac {1} {tan(FOV/2)}$$\nFOV是相机的垂直视角，而不是水平视角\nwidth:屏幕宽度\nheight:屏幕高度\nfar: 到远处平面的距离（>0 && > near）\nnear: 到近处平面的距离（>0）\n\n***\n## 虚拟世界的顶点画到在屏幕上经过的变换过程\n变换后的坐标 = 视口矩阵 x 投影矩阵 x 视图矩阵 x 模型矩阵 x 模型点坐标","slug":"OpenGLES-matrix-usage","published":1,"updated":"2016-12-12T15:23:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlvoa2f0000jtu3c5qaw5g7","content":"<h1 id=\"矩阵的应用\"><a href=\"#矩阵的应用\" class=\"headerlink\" title=\"矩阵的应用\"></a>矩阵的应用</h1><h2 id=\"模型矩阵\"><a href=\"#模型矩阵\" class=\"headerlink\" title=\"模型矩阵\"></a>模型矩阵</h2><p>模型矩阵是相对于世界坐标系的，包含一系列平移、缩放、旋转的变换信息的矩阵。它与点的位置没有任何关系。基本的模型矩阵有平移矩阵、缩放矩阵、旋转矩阵，模型矩阵左乘模型矩阵，还是模型矩阵。点坐标左乘模型矩阵就能得到最终变换的坐标。因此，多个顶点能共用同一个模型矩阵，一般一个模型里的所有顶点都共用一个模型矩阵。</p>\n<h3 id=\"平移矩阵\"><a href=\"#平移矩阵\" class=\"headerlink\" title=\"平移矩阵\"></a>平移矩阵</h3><p>$$<br> \\left[<br> \\begin{matrix}<br>   1 &amp; 0 &amp; 0 &amp; X_t \\\\<br>   0 &amp; 1 &amp; 0 &amp; Y_t \\\\<br>   0 &amp; 0 &amp; 1 &amp; Z_t \\\\<br>   0 &amp; 0 &amp; 0 &amp; 1<br>  \\end{matrix}<br>  \\right]<br>$$<br>例如：Vec(2,2,0) 沿着X轴平移3，沿着Y轴平移3，则：<br>$$<br>\\left[<br>    \\begin{matrix}<br>        1 &amp; 0 &amp; 0 &amp; 3 \\\\<br>        0 &amp; 1 &amp; 0 &amp; 3 \\\\<br>        0 &amp; 0 &amp; 1 &amp; 0 \\\\<br>        0 &amp; 0 &amp; 0 &amp; 1<br>    \\end{matrix}<br>\\right]<br>\\left[<br>    \\begin{matrix}<br>        2 \\\\<br>        2 \\\\<br>        0 \\\\<br>        1<br>    \\end{matrix}<br>\\right]<br>=<br>\\left[<br>    \\begin{matrix}<br>        5 \\\\<br>        5 \\\\<br>        0 \\\\<br>        1<br>    \\end{matrix}<br>\\right]<br>$$</p>\n<p>###缩放矩阵<br>$$<br>\\begin{bmatrix}<br>    S_x &amp; 0 &amp; 0 &amp; 0 \\\\<br>    0 &amp; S_y &amp; 0 &amp; 0 \\\\<br>    0 &amp; 0 &amp; S_z &amp; 0 \\\\<br>    0 &amp; 0 &amp; 0 &amp; 1<br>\\end{bmatrix}<br>$$</p>\n<h3 id=\"旋转矩阵\"><a href=\"#旋转矩阵\" class=\"headerlink\" title=\"旋转矩阵\"></a>旋转矩阵</h3><h4 id=\"点绕z轴旋转：\"><a href=\"#点绕z轴旋转：\" class=\"headerlink\" title=\"点绕z轴旋转：\"></a>点绕z轴旋转：</h4><p>（左手坐标系，其中θ是Yaw角）：<br>$$<br>\\begin{bmatrix}<br>    \\cos\\theta &amp; \\sin\\theta &amp; 0 &amp; 0 \\\\<br>    -\\sin\\theta &amp; \\cos\\theta &amp; 0 &amp; 0 \\\\<br>    0 &amp; 0 &amp; 1 &amp; 0 \\\\<br>    0 &amp; 0 &amp; 0 &amp; 1<br>\\end{bmatrix}<br>$$<br>（右手坐标系，其中θ是Yaw角）：<br>$$<br>\\begin{bmatrix}<br>    \\cos\\theta &amp; -\\sin\\theta &amp; 0 &amp; 0 \\\\<br>    \\sin\\theta &amp; \\cos\\theta &amp; 0 &amp; 0 \\\\<br>    0 &amp; 0 &amp; 1 &amp; 0 \\\\<br>    0 &amp; 0 &amp; 0 &amp; 1<br>\\end{bmatrix}<br>$$</p>\n<h4 id=\"点绕x轴旋转：\"><a href=\"#点绕x轴旋转：\" class=\"headerlink\" title=\"点绕x轴旋转：\"></a>点绕x轴旋转：</h4><p>（左手坐标系，其中θ是roll角）：<br>$$\\begin{bmatrix}<br>    1 &amp; 0 &amp; 0 &amp; 0 \\\\<br>    0 &amp; \\cos\\theta &amp; \\sin\\theta &amp; 0 \\\\<br>    0 &amp; -\\sin\\theta &amp; \\cos\\theta &amp; 0 \\\\<br>    0 &amp; 0 &amp; 0 &amp; 1<br>\\end{bmatrix}$$<br>（右手坐标系，其中θ是roll角）：<br>$$\\begin{bmatrix}<br>    1 &amp; 0 &amp; 0 &amp; 0 \\\\<br>    0 &amp; \\cos\\theta &amp; -\\sin\\theta &amp; 0 \\\\<br>    0 &amp; \\sin\\theta &amp; \\cos\\theta &amp; 0 \\\\<br>    0 &amp; 0 &amp; 0 &amp; 1<br>\\end{bmatrix}$$</p>\n<h4 id=\"点绕y轴旋转\"><a href=\"#点绕y轴旋转\" class=\"headerlink\" title=\"点绕y轴旋转\"></a>点绕y轴旋转</h4><p>（左手坐标系，其中θ是pitch角）：<br>$$\\begin{bmatrix}<br>    \\cos\\theta &amp; 0 &amp; -\\sin\\theta &amp; 0\\\\<br>    0 &amp; 1 &amp; 0 &amp; 0\\\\<br>    \\sin\\theta &amp; 0 &amp; \\cos\\theta &amp; 0 \\\\<br>    0 &amp; 0 &amp; 0 &amp; 1<br>\\end{bmatrix}$$<br>（右手坐标系，其中θ是pitch角）<br>$$\\begin{bmatrix}<br>    \\cos\\theta &amp; 0 &amp; \\sin\\theta &amp; 0\\\\<br>    0 &amp; 1 &amp; 0 &amp; 0\\\\<br>    -\\sin\\theta &amp; 0 &amp; \\cos\\theta &amp; 0 \\\\<br>    0 &amp; 0 &amp; 0 &amp; 1<br>\\end{bmatrix}$$</p>\n<hr>\n<h2 id=\"视图矩阵\"><a href=\"#视图矩阵\" class=\"headerlink\" title=\"视图矩阵\"></a>视图矩阵</h2><p>概念：视图矩阵是本地坐标系在世界坐标系中的变换的模型矩阵的逆矩阵，因此视图矩阵也是可以分为平移、缩放、旋转的。<br>好吧，说点人话，一个摄像机，在世界坐标系中，经过模型矩阵<em>M1</em>（模型变换），从原点沿着X轴正方向前进10单位。这时候，摄像机的视图矩阵为<em>M2</em>，而且<em>M2</em>是<em>M1</em>的逆矩阵。<em>M2</em>的几何含义：假设摄像机一直原地不动，而是这个世界以<em>M2</em>为模型矩阵进行变换，往后移动了10个单位，也就是摄像机在世界坐标系下的平移、缩放、旋转等变换的反向过程。<br>作用：获得相对坐标（本地坐标）。<br>将视图矩阵左乘一个物体最终的模型矩阵，得到的矩阵就是所谓的“模型视图矩阵”。“模型视图矩阵”左乘一个世界坐标系下的坐标点，得到的是相对于本地坐标系的坐标点。<br>举个例子：一个摄像机和一个物体，一起同样的速度和方向，从世界坐标系的原点沿着X轴的正方形移动了10个单位。摄像机的视图矩阵左乘物体的模型矩阵（模型视图矩阵）表示的含义可以理解为：世界往X轴的负方向移动了10个单位，然后在沿x轴正方向移动10个单位，因此任何一个坐标点乘以这个模型视图矩阵，都不会发生变化，明显，摄像机和物体相对静止的。</p>\n<hr>\n<h2 id=\"投影矩阵\"><a href=\"#投影矩阵\" class=\"headerlink\" title=\"投影矩阵\"></a>投影矩阵</h2><p>投影矩阵就是把三维空间投影到二维的空间。方式有正交和透视两种。</p>\n<h3 id=\"正交投影矩阵\"><a href=\"#正交投影矩阵\" class=\"headerlink\" title=\"正交投影矩阵\"></a>正交投影矩阵</h3><ul>\n<li>作用：正交投影矩阵可以把虚拟坐标转换回归一化设备坐标（正交投影矩阵乘以虚拟坐标）。</li>\n<li>归一化设备坐标：在OpenGL里，一切物体都要映射到X、Y轴和Z轴的[-1,1]范围内，这个范围内的坐标被称为归一化设备坐标，其独立于屏幕实际的尺寸。归一化设备坐标假定坐标空间是个正方形。</li>\n<li>虚拟坐标空间：为了让屏幕形状考虑进来，把宽和高中较小的一个的范围定在[-1,1]内，另外一个根据屏幕尺寸比例调整为较大的范围。</li>\n</ul>\n<p>正交投影矩阵如下：<br>$$<br> \\left[<br> \\begin{matrix}<br>   \\frac{2}{right-left} &amp; 0 &amp; 0 &amp; -\\frac{right+left}{right-left} \\\\<br>   0 &amp; \\frac{2}{top-bottom} &amp; 0 &amp; -\\frac{top+bottom}{top-bottom} \\\\<br>   0 &amp; 0 &amp;  -\\frac{2}{far-near} &amp; -\\frac{far+near}{far-near} \\\\<br>   0 &amp; 0 &amp; 0 &amp; 1<br>  \\end{matrix}<br>  \\right]<br>$$<br>注意：使用的是左手坐标系还是右手坐标系，这两者的Z轴是相反的。<br>其实在一个顶点着色器的顶点位置(gl_Position)变为归一化设备坐标前，还会做透视除法（xyz都除以w）。</p>\n<h3 id=\"透视投影矩阵\"><a href=\"#透视投影矩阵\" class=\"headerlink\" title=\"透视投影矩阵\"></a>透视投影矩阵</h3><p>透视投影矩阵最大的作用是产生正确的w值。w值可以理解为距离，w值越大，离中心点越近。</p>\n<p>透视投影矩阵<br>$$<br> \\left[<br> \\begin{matrix}<br>   \\frac{α}{width/height} &amp; 0 &amp; 0 &amp; 0 \\\\<br>   0 &amp; α &amp; 0 &amp; 0 \\\\<br>   0 &amp; 0 &amp; -\\frac{far+near}{far-near} &amp; -\\frac{2*far*near}{far-near} \\\\<br>   0 &amp; 0 &amp; -1 &amp; 0<br>  \\end{matrix}<br>  \\right]<br>$$<br>其中α是焦距:<br>$$α = \\frac {1} {tan(FOV/2)}$$<br>FOV是相机的垂直视角，而不是水平视角<br>width:屏幕宽度<br>height:屏幕高度<br>far: 到远处平面的距离（&gt;0 &amp;&amp; &gt; near）<br>near: 到近处平面的距离（&gt;0）</p>\n<hr>\n<h2 id=\"虚拟世界的顶点画到在屏幕上经过的变换过程\"><a href=\"#虚拟世界的顶点画到在屏幕上经过的变换过程\" class=\"headerlink\" title=\"虚拟世界的顶点画到在屏幕上经过的变换过程\"></a>虚拟世界的顶点画到在屏幕上经过的变换过程</h2><p>变换后的坐标 = 视口矩阵 x 投影矩阵 x 视图矩阵 x 模型矩阵 x 模型点坐标</p>\n","excerpt":"","more":"<h1 id=\"矩阵的应用\"><a href=\"#矩阵的应用\" class=\"headerlink\" title=\"矩阵的应用\"></a>矩阵的应用</h1><h2 id=\"模型矩阵\"><a href=\"#模型矩阵\" class=\"headerlink\" title=\"模型矩阵\"></a>模型矩阵</h2><p>模型矩阵是相对于世界坐标系的，包含一系列平移、缩放、旋转的变换信息的矩阵。它与点的位置没有任何关系。基本的模型矩阵有平移矩阵、缩放矩阵、旋转矩阵，模型矩阵左乘模型矩阵，还是模型矩阵。点坐标左乘模型矩阵就能得到最终变换的坐标。因此，多个顶点能共用同一个模型矩阵，一般一个模型里的所有顶点都共用一个模型矩阵。</p>\n<h3 id=\"平移矩阵\"><a href=\"#平移矩阵\" class=\"headerlink\" title=\"平移矩阵\"></a>平移矩阵</h3><p>$$<br> \\left[<br> \\begin{matrix}<br>   1 &amp; 0 &amp; 0 &amp; X_t \\\\<br>   0 &amp; 1 &amp; 0 &amp; Y_t \\\\<br>   0 &amp; 0 &amp; 1 &amp; Z_t \\\\<br>   0 &amp; 0 &amp; 0 &amp; 1<br>  \\end{matrix}<br>  \\right]<br>$$<br>例如：Vec(2,2,0) 沿着X轴平移3，沿着Y轴平移3，则：<br>$$<br>\\left[<br>    \\begin{matrix}<br>        1 &amp; 0 &amp; 0 &amp; 3 \\\\<br>        0 &amp; 1 &amp; 0 &amp; 3 \\\\<br>        0 &amp; 0 &amp; 1 &amp; 0 \\\\<br>        0 &amp; 0 &amp; 0 &amp; 1<br>    \\end{matrix}<br>\\right]<br>\\left[<br>    \\begin{matrix}<br>        2 \\\\<br>        2 \\\\<br>        0 \\\\<br>        1<br>    \\end{matrix}<br>\\right]<br>=<br>\\left[<br>    \\begin{matrix}<br>        5 \\\\<br>        5 \\\\<br>        0 \\\\<br>        1<br>    \\end{matrix}<br>\\right]<br>$$</p>\n<p>###缩放矩阵<br>$$<br>\\begin{bmatrix}<br>    S_x &amp; 0 &amp; 0 &amp; 0 \\\\<br>    0 &amp; S_y &amp; 0 &amp; 0 \\\\<br>    0 &amp; 0 &amp; S_z &amp; 0 \\\\<br>    0 &amp; 0 &amp; 0 &amp; 1<br>\\end{bmatrix}<br>$$</p>\n<h3 id=\"旋转矩阵\"><a href=\"#旋转矩阵\" class=\"headerlink\" title=\"旋转矩阵\"></a>旋转矩阵</h3><h4 id=\"点绕z轴旋转：\"><a href=\"#点绕z轴旋转：\" class=\"headerlink\" title=\"点绕z轴旋转：\"></a>点绕z轴旋转：</h4><p>（左手坐标系，其中θ是Yaw角）：<br>$$<br>\\begin{bmatrix}<br>    \\cos\\theta &amp; \\sin\\theta &amp; 0 &amp; 0 \\\\<br>    -\\sin\\theta &amp; \\cos\\theta &amp; 0 &amp; 0 \\\\<br>    0 &amp; 0 &amp; 1 &amp; 0 \\\\<br>    0 &amp; 0 &amp; 0 &amp; 1<br>\\end{bmatrix}<br>$$<br>（右手坐标系，其中θ是Yaw角）：<br>$$<br>\\begin{bmatrix}<br>    \\cos\\theta &amp; -\\sin\\theta &amp; 0 &amp; 0 \\\\<br>    \\sin\\theta &amp; \\cos\\theta &amp; 0 &amp; 0 \\\\<br>    0 &amp; 0 &amp; 1 &amp; 0 \\\\<br>    0 &amp; 0 &amp; 0 &amp; 1<br>\\end{bmatrix}<br>$$</p>\n<h4 id=\"点绕x轴旋转：\"><a href=\"#点绕x轴旋转：\" class=\"headerlink\" title=\"点绕x轴旋转：\"></a>点绕x轴旋转：</h4><p>（左手坐标系，其中θ是roll角）：<br>$$\\begin{bmatrix}<br>    1 &amp; 0 &amp; 0 &amp; 0 \\\\<br>    0 &amp; \\cos\\theta &amp; \\sin\\theta &amp; 0 \\\\<br>    0 &amp; -\\sin\\theta &amp; \\cos\\theta &amp; 0 \\\\<br>    0 &amp; 0 &amp; 0 &amp; 1<br>\\end{bmatrix}$$<br>（右手坐标系，其中θ是roll角）：<br>$$\\begin{bmatrix}<br>    1 &amp; 0 &amp; 0 &amp; 0 \\\\<br>    0 &amp; \\cos\\theta &amp; -\\sin\\theta &amp; 0 \\\\<br>    0 &amp; \\sin\\theta &amp; \\cos\\theta &amp; 0 \\\\<br>    0 &amp; 0 &amp; 0 &amp; 1<br>\\end{bmatrix}$$</p>\n<h4 id=\"点绕y轴旋转\"><a href=\"#点绕y轴旋转\" class=\"headerlink\" title=\"点绕y轴旋转\"></a>点绕y轴旋转</h4><p>（左手坐标系，其中θ是pitch角）：<br>$$\\begin{bmatrix}<br>    \\cos\\theta &amp; 0 &amp; -\\sin\\theta &amp; 0\\\\<br>    0 &amp; 1 &amp; 0 &amp; 0\\\\<br>    \\sin\\theta &amp; 0 &amp; \\cos\\theta &amp; 0 \\\\<br>    0 &amp; 0 &amp; 0 &amp; 1<br>\\end{bmatrix}$$<br>（右手坐标系，其中θ是pitch角）<br>$$\\begin{bmatrix}<br>    \\cos\\theta &amp; 0 &amp; \\sin\\theta &amp; 0\\\\<br>    0 &amp; 1 &amp; 0 &amp; 0\\\\<br>    -\\sin\\theta &amp; 0 &amp; \\cos\\theta &amp; 0 \\\\<br>    0 &amp; 0 &amp; 0 &amp; 1<br>\\end{bmatrix}$$</p>\n<hr>\n<h2 id=\"视图矩阵\"><a href=\"#视图矩阵\" class=\"headerlink\" title=\"视图矩阵\"></a>视图矩阵</h2><p>概念：视图矩阵是本地坐标系在世界坐标系中的变换的模型矩阵的逆矩阵，因此视图矩阵也是可以分为平移、缩放、旋转的。<br>好吧，说点人话，一个摄像机，在世界坐标系中，经过模型矩阵<em>M1</em>（模型变换），从原点沿着X轴正方向前进10单位。这时候，摄像机的视图矩阵为<em>M2</em>，而且<em>M2</em>是<em>M1</em>的逆矩阵。<em>M2</em>的几何含义：假设摄像机一直原地不动，而是这个世界以<em>M2</em>为模型矩阵进行变换，往后移动了10个单位，也就是摄像机在世界坐标系下的平移、缩放、旋转等变换的反向过程。<br>作用：获得相对坐标（本地坐标）。<br>将视图矩阵左乘一个物体最终的模型矩阵，得到的矩阵就是所谓的“模型视图矩阵”。“模型视图矩阵”左乘一个世界坐标系下的坐标点，得到的是相对于本地坐标系的坐标点。<br>举个例子：一个摄像机和一个物体，一起同样的速度和方向，从世界坐标系的原点沿着X轴的正方形移动了10个单位。摄像机的视图矩阵左乘物体的模型矩阵（模型视图矩阵）表示的含义可以理解为：世界往X轴的负方向移动了10个单位，然后在沿x轴正方向移动10个单位，因此任何一个坐标点乘以这个模型视图矩阵，都不会发生变化，明显，摄像机和物体相对静止的。</p>\n<hr>\n<h2 id=\"投影矩阵\"><a href=\"#投影矩阵\" class=\"headerlink\" title=\"投影矩阵\"></a>投影矩阵</h2><p>投影矩阵就是把三维空间投影到二维的空间。方式有正交和透视两种。</p>\n<h3 id=\"正交投影矩阵\"><a href=\"#正交投影矩阵\" class=\"headerlink\" title=\"正交投影矩阵\"></a>正交投影矩阵</h3><ul>\n<li>作用：正交投影矩阵可以把虚拟坐标转换回归一化设备坐标（正交投影矩阵乘以虚拟坐标）。</li>\n<li>归一化设备坐标：在OpenGL里，一切物体都要映射到X、Y轴和Z轴的[-1,1]范围内，这个范围内的坐标被称为归一化设备坐标，其独立于屏幕实际的尺寸。归一化设备坐标假定坐标空间是个正方形。</li>\n<li>虚拟坐标空间：为了让屏幕形状考虑进来，把宽和高中较小的一个的范围定在[-1,1]内，另外一个根据屏幕尺寸比例调整为较大的范围。</li>\n</ul>\n<p>正交投影矩阵如下：<br>$$<br> \\left[<br> \\begin{matrix}<br>   \\frac{2}{right-left} &amp; 0 &amp; 0 &amp; -\\frac{right+left}{right-left} \\\\<br>   0 &amp; \\frac{2}{top-bottom} &amp; 0 &amp; -\\frac{top+bottom}{top-bottom} \\\\<br>   0 &amp; 0 &amp;  -\\frac{2}{far-near} &amp; -\\frac{far+near}{far-near} \\\\<br>   0 &amp; 0 &amp; 0 &amp; 1<br>  \\end{matrix}<br>  \\right]<br>$$<br>注意：使用的是左手坐标系还是右手坐标系，这两者的Z轴是相反的。<br>其实在一个顶点着色器的顶点位置(gl_Position)变为归一化设备坐标前，还会做透视除法（xyz都除以w）。</p>\n<h3 id=\"透视投影矩阵\"><a href=\"#透视投影矩阵\" class=\"headerlink\" title=\"透视投影矩阵\"></a>透视投影矩阵</h3><p>透视投影矩阵最大的作用是产生正确的w值。w值可以理解为距离，w值越大，离中心点越近。</p>\n<p>透视投影矩阵<br>$$<br> \\left[<br> \\begin{matrix}<br>   \\frac{α}{width/height} &amp; 0 &amp; 0 &amp; 0 \\\\<br>   0 &amp; α &amp; 0 &amp; 0 \\\\<br>   0 &amp; 0 &amp; -\\frac{far+near}{far-near} &amp; -\\frac{2*far*near}{far-near} \\\\<br>   0 &amp; 0 &amp; -1 &amp; 0<br>  \\end{matrix}<br>  \\right]<br>$$<br>其中α是焦距:<br>$$α = \\frac {1} {tan(FOV/2)}$$<br>FOV是相机的垂直视角，而不是水平视角<br>width:屏幕宽度<br>height:屏幕高度<br>far: 到远处平面的距离（&gt;0 &amp;&amp; &gt; near）<br>near: 到近处平面的距离（&gt;0）</p>\n<hr>\n<h2 id=\"虚拟世界的顶点画到在屏幕上经过的变换过程\"><a href=\"#虚拟世界的顶点画到在屏幕上经过的变换过程\" class=\"headerlink\" title=\"虚拟世界的顶点画到在屏幕上经过的变换过程\"></a>虚拟世界的顶点画到在屏幕上经过的变换过程</h2><p>变换后的坐标 = 视口矩阵 x 投影矩阵 x 视图矩阵 x 模型矩阵 x 模型点坐标</p>\n"},{"title":"Pawn的Relevancy（关联）Checklist分析（基于虚幻3）","date":"2016-11-26T09:41:10.000Z","_content":"\n在项目开发中，我发现了游戏中有一个bug。怪物会无端端消失，移动一下玩家角色，怪物又会重新出现。特别是在玩家角色前面有遮挡物的时候，很容易重现。不难猜想，就是虚幻的关联导致的这个现象，因此唯有对Pawn的关联的检查流程仔细分析。\n追根溯源，最后终于定位到了如下函数：\n\n![Pawn的关联判断函数.png](http://upload-images.jianshu.io/upload_images/3713845-7cd88fe288a20426.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这个函数具体实现如下：\n```\nUBOOL APawn ::IsNetRelevantFor( APlayerController* RealViewer, AActor * Viewer, const FVector & SrcLocation)\n{\n     if ( bAlwaysRelevant )\n          return TRUE ;\n     if ( (NetRelevancyTime == GWorld->GetTimeSeconds ()) && (RealViewer == LastRealViewer) && (Viewer == LastViewer) )\n    {\n          return bCachedRelevant ;\n    }\n     if( IsOwnedBy (Viewer) || IsOwnedBy(RealViewer ) || this==Viewer || Viewer== Instigator\n         || IsBasedOn(Viewer ) || (Viewer && Viewer->IsBasedOn (this)) || RealViewer->bReplicateAllPawns\n         || ( Controller && ((Location - Viewer->Location ).SizeSquared() < AlwaysRelevantDistanceSquared )) || HasAudibleAmbientSound(SrcLocation ) )\n          return CacheNetRelevancy(TRUE ,RealViewer, Viewer);\n     else if ( (bHidden || bOnlyOwnerSee) && !bBlockActors )\n          return CacheNetRelevancy(FALSE ,RealViewer, Viewer);\n     else if ( Base && ( BaseSkelComponent || ((Base == Owner) && !bOnlyOwnerSee )) )\n          return Base ->IsNetRelevantFor( RealViewer, Viewer, SrcLocation );\n     else\n    {\n#ifdef USE_DISTANCE_FOG_OCCLUSION\n          // check distance fog\n          if ( RealViewer->BeyondFogDistance (SrcLocation, Location) )\n              return CacheNetRelevancy(false ,RealViewer, Viewer);\n#endif\n          // check against BSP - check head and center\n          //debugf(TEXT(\"Check relevance of %s\"),*(PlayerReplicationInfo->PlayerName));\n          FCheckResult Hit (1.f);\n          if ( !GWorld ->SingleLineCheck( Hit, this , Location + FVector (0.f,0.f,BaseEyeHeight), SrcLocation, TRACE_World|TRACE_StopAtAnyHit |TRACE_ComplexCollision, FVector(0.f,0.f,0.f) )\n             && ! GWorld->SingleLineCheck ( Hit, this, Location, SrcLocation , TRACE_World|TRACE_StopAtAnyHit |TRACE_ComplexCollision, FVector(0.f,0.f,0.f) )\n             && !IsRelevantThroughPortals (RealViewer) )\n         {\n              return CacheNetRelevancy(FALSE ,RealViewer, Viewer);\n         }\n          return CacheNetRelevancy(TRUE ,RealViewer, Viewer);\n    }\n}\n```\n可以看到，Pawn的关联判断流程：\n1、先判断是否是bAlwaysRelevant，如果是，则直接返回true\n2、判断是否已经检查过了，是则直接返回上一次检查结果\n3、判断以下条件，有一个成立则认为是关联：\n           是否被Viewer拥有，\n           是否被RealViewer拥有，是否viewer就是自己本身，\n           viewer是否是本身的Instigator（注意，Instigator 和 owner不要混淆了哦），\n           是否base on viewer或者是viewer base on自己，\n           是否RealViewer的bReplicateAllPawns为true，\n           自己和viewer是否在一定会关联的距离内，\n           是否会听到目标位置的声音\n4、判断 ( (bHidden || bOnlyOwnerSee) && !bBlockActors )，不能被碰撞，而且被隐藏了或者自由owner能看见。\n5、判断是否有base，有的话检查base是否是关联的，如果base是关联，则这个pawn也是关联的。\n6、以下条件任何一个成立，则返回不关联\n            通过线性检测，检测到这个Pawn的眼睛的位置和SrcLocation之间有遮挡（SrcLocation 可以理解为Viewer的location，当然为了更好的体验感，其实还增加了预判，具体的实现在FNetViewer::FNetViewer()函数中）；\n            这个Pawn的位置和SrcLocation之间有遮挡；\n            不能通过某个房间的入口看得到RealViewer（通过遍历检查RealViewer::VisiblePortals的成员实现。TickSpecial()会不断调用CheckPortalVisible()更新Controller中的VisiblePortals）；\n\n问题就出在第6个条件那里。\n这个Pawn就是要判断是否关联的怪物，而第六个条件只是判断了：怪物的眼睛到玩家的位置做射线检测、怪物的位置到玩家的位置做射线检测 ，但是，玩家的眼睛的位置到怪物的位置这个射线检测没有判断，因此如果怪物检测不到玩家，而玩家却刚好能看得到怪物的时候，就会出现这个怪物不关联的bug了。\n知道问题，改起来也简单，增加一个射线检测就行了。上面的函数改为下面这样，就OK了。\n\n```\nUBOOL APawn :: IsNetRelevantFor( APlayerController * RealViewer , AActor * Viewer, const FVector & SrcLocation )\n{\n     if ( bAlwaysRelevant )\n          return TRUE ;\n     if ( (NetRelevancyTime == GWorld ->GetTimeSeconds ()) && ( RealViewer == LastRealViewer ) && (Viewer == LastViewer) )\n    {\n          return bCachedRelevant ;\n    }\n     if ( IsOwnedBy ( Viewer) || IsOwnedBy (RealViewer ) || this ==Viewer || Viewer== Instigator\n         || IsBasedOn (Viewer ) || ( Viewer && Viewer ->IsBasedOn ( this)) || RealViewer ->bReplicateAllPawns\n\n         || ( Controller && ((Location - Viewer ->Location ). SizeSquared() < AlwaysRelevantDistanceSquared )) || HasAudibleAmbientSound (SrcLocation ) )\n          return CacheNetRelevancy (TRUE , RealViewer, Viewer );\n     else if ( ( bHidden || bOnlyOwnerSee ) && !bBlockActors )\n          return CacheNetRelevancy (FALSE , RealViewer, Viewer );\n     else if ( Base && ( BaseSkelComponent || ((Base == Owner ) && !bOnlyOwnerSee )) )\n          return Base -> IsNetRelevantFor( RealViewer , Viewer , SrcLocation );\n     else\n    {\n#ifdef USE_DISTANCE_FOG_OCCLUSION\n          // check distance fog\n          if ( RealViewer ->BeyondFogDistance ( SrcLocation, Location ) )\n              return CacheNetRelevancy (false , RealViewer, Viewer );\n#endif\n          // check against BSP - check head and center\n          //debugf(TEXT(\"Check relevance of %s\"),*(PlayerReplicationInfo->PlayerName));\n          FCheckResult Hit (1.f);\n          if ( !GWorld -> SingleLineCheck( Hit , this , Location + FVector (0.f,0.f, BaseEyeHeight), SrcLocation , TRACE_World |TRACE_StopAtAnyHit | TRACE_ComplexCollision, FVector (0.f,0.f,0.f) )\n             && ! GWorld ->SingleLineCheck ( Hit, this , Location , SrcLocation , TRACE_World |TRACE_StopAtAnyHit | TRACE_ComplexCollision, FVector (0.f,0.f,0.f) )\n              && !IsRelevantThroughPortals ( RealViewer) )\n         {\n              UBOOL RealViewerCanSeeThis = TRUE;\n              APawn * RealViewerPawn = RealViewer ->Pawn ;\n              if (NULL != RealViewerPawn)\n             {\n                  RealViewerCanSeeThis = GWorld ->SingleLineCheck ( Hit, this , RealViewerPawn ->Location + FVector (0.f,0.f,RealViewerPawn -> BaseEyeHeight), Location , TRACE_World |TRACE_StopAtAnyHit | TRACE_ComplexCollision, FVector (0.f,0.f,0.f));\n             }\n              if (RealViewerCanSeeThis )\n                  return CacheNetRelevancy (TRUE , RealViewer, Viewer );\n              else\n                  return CacheNetRelevancy (FALSE , RealViewer, Viewer );\n         }\n          return CacheNetRelevancy (TRUE , RealViewer, Viewer );\n    }\n}\n```","source":"_posts/Pawn的Relevancy（关联）Checklist分析（基于虚幻3）.md","raw":"---\ntitle: Pawn的Relevancy（关联）Checklist分析（基于虚幻3）\ndate: 2016-11-26 17:41:10\ncategories: 虚幻3\ntags:\n---\n\n在项目开发中，我发现了游戏中有一个bug。怪物会无端端消失，移动一下玩家角色，怪物又会重新出现。特别是在玩家角色前面有遮挡物的时候，很容易重现。不难猜想，就是虚幻的关联导致的这个现象，因此唯有对Pawn的关联的检查流程仔细分析。\n追根溯源，最后终于定位到了如下函数：\n\n![Pawn的关联判断函数.png](http://upload-images.jianshu.io/upload_images/3713845-7cd88fe288a20426.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n这个函数具体实现如下：\n```\nUBOOL APawn ::IsNetRelevantFor( APlayerController* RealViewer, AActor * Viewer, const FVector & SrcLocation)\n{\n     if ( bAlwaysRelevant )\n          return TRUE ;\n     if ( (NetRelevancyTime == GWorld->GetTimeSeconds ()) && (RealViewer == LastRealViewer) && (Viewer == LastViewer) )\n    {\n          return bCachedRelevant ;\n    }\n     if( IsOwnedBy (Viewer) || IsOwnedBy(RealViewer ) || this==Viewer || Viewer== Instigator\n         || IsBasedOn(Viewer ) || (Viewer && Viewer->IsBasedOn (this)) || RealViewer->bReplicateAllPawns\n         || ( Controller && ((Location - Viewer->Location ).SizeSquared() < AlwaysRelevantDistanceSquared )) || HasAudibleAmbientSound(SrcLocation ) )\n          return CacheNetRelevancy(TRUE ,RealViewer, Viewer);\n     else if ( (bHidden || bOnlyOwnerSee) && !bBlockActors )\n          return CacheNetRelevancy(FALSE ,RealViewer, Viewer);\n     else if ( Base && ( BaseSkelComponent || ((Base == Owner) && !bOnlyOwnerSee )) )\n          return Base ->IsNetRelevantFor( RealViewer, Viewer, SrcLocation );\n     else\n    {\n#ifdef USE_DISTANCE_FOG_OCCLUSION\n          // check distance fog\n          if ( RealViewer->BeyondFogDistance (SrcLocation, Location) )\n              return CacheNetRelevancy(false ,RealViewer, Viewer);\n#endif\n          // check against BSP - check head and center\n          //debugf(TEXT(\"Check relevance of %s\"),*(PlayerReplicationInfo->PlayerName));\n          FCheckResult Hit (1.f);\n          if ( !GWorld ->SingleLineCheck( Hit, this , Location + FVector (0.f,0.f,BaseEyeHeight), SrcLocation, TRACE_World|TRACE_StopAtAnyHit |TRACE_ComplexCollision, FVector(0.f,0.f,0.f) )\n             && ! GWorld->SingleLineCheck ( Hit, this, Location, SrcLocation , TRACE_World|TRACE_StopAtAnyHit |TRACE_ComplexCollision, FVector(0.f,0.f,0.f) )\n             && !IsRelevantThroughPortals (RealViewer) )\n         {\n              return CacheNetRelevancy(FALSE ,RealViewer, Viewer);\n         }\n          return CacheNetRelevancy(TRUE ,RealViewer, Viewer);\n    }\n}\n```\n可以看到，Pawn的关联判断流程：\n1、先判断是否是bAlwaysRelevant，如果是，则直接返回true\n2、判断是否已经检查过了，是则直接返回上一次检查结果\n3、判断以下条件，有一个成立则认为是关联：\n           是否被Viewer拥有，\n           是否被RealViewer拥有，是否viewer就是自己本身，\n           viewer是否是本身的Instigator（注意，Instigator 和 owner不要混淆了哦），\n           是否base on viewer或者是viewer base on自己，\n           是否RealViewer的bReplicateAllPawns为true，\n           自己和viewer是否在一定会关联的距离内，\n           是否会听到目标位置的声音\n4、判断 ( (bHidden || bOnlyOwnerSee) && !bBlockActors )，不能被碰撞，而且被隐藏了或者自由owner能看见。\n5、判断是否有base，有的话检查base是否是关联的，如果base是关联，则这个pawn也是关联的。\n6、以下条件任何一个成立，则返回不关联\n            通过线性检测，检测到这个Pawn的眼睛的位置和SrcLocation之间有遮挡（SrcLocation 可以理解为Viewer的location，当然为了更好的体验感，其实还增加了预判，具体的实现在FNetViewer::FNetViewer()函数中）；\n            这个Pawn的位置和SrcLocation之间有遮挡；\n            不能通过某个房间的入口看得到RealViewer（通过遍历检查RealViewer::VisiblePortals的成员实现。TickSpecial()会不断调用CheckPortalVisible()更新Controller中的VisiblePortals）；\n\n问题就出在第6个条件那里。\n这个Pawn就是要判断是否关联的怪物，而第六个条件只是判断了：怪物的眼睛到玩家的位置做射线检测、怪物的位置到玩家的位置做射线检测 ，但是，玩家的眼睛的位置到怪物的位置这个射线检测没有判断，因此如果怪物检测不到玩家，而玩家却刚好能看得到怪物的时候，就会出现这个怪物不关联的bug了。\n知道问题，改起来也简单，增加一个射线检测就行了。上面的函数改为下面这样，就OK了。\n\n```\nUBOOL APawn :: IsNetRelevantFor( APlayerController * RealViewer , AActor * Viewer, const FVector & SrcLocation )\n{\n     if ( bAlwaysRelevant )\n          return TRUE ;\n     if ( (NetRelevancyTime == GWorld ->GetTimeSeconds ()) && ( RealViewer == LastRealViewer ) && (Viewer == LastViewer) )\n    {\n          return bCachedRelevant ;\n    }\n     if ( IsOwnedBy ( Viewer) || IsOwnedBy (RealViewer ) || this ==Viewer || Viewer== Instigator\n         || IsBasedOn (Viewer ) || ( Viewer && Viewer ->IsBasedOn ( this)) || RealViewer ->bReplicateAllPawns\n\n         || ( Controller && ((Location - Viewer ->Location ). SizeSquared() < AlwaysRelevantDistanceSquared )) || HasAudibleAmbientSound (SrcLocation ) )\n          return CacheNetRelevancy (TRUE , RealViewer, Viewer );\n     else if ( ( bHidden || bOnlyOwnerSee ) && !bBlockActors )\n          return CacheNetRelevancy (FALSE , RealViewer, Viewer );\n     else if ( Base && ( BaseSkelComponent || ((Base == Owner ) && !bOnlyOwnerSee )) )\n          return Base -> IsNetRelevantFor( RealViewer , Viewer , SrcLocation );\n     else\n    {\n#ifdef USE_DISTANCE_FOG_OCCLUSION\n          // check distance fog\n          if ( RealViewer ->BeyondFogDistance ( SrcLocation, Location ) )\n              return CacheNetRelevancy (false , RealViewer, Viewer );\n#endif\n          // check against BSP - check head and center\n          //debugf(TEXT(\"Check relevance of %s\"),*(PlayerReplicationInfo->PlayerName));\n          FCheckResult Hit (1.f);\n          if ( !GWorld -> SingleLineCheck( Hit , this , Location + FVector (0.f,0.f, BaseEyeHeight), SrcLocation , TRACE_World |TRACE_StopAtAnyHit | TRACE_ComplexCollision, FVector (0.f,0.f,0.f) )\n             && ! GWorld ->SingleLineCheck ( Hit, this , Location , SrcLocation , TRACE_World |TRACE_StopAtAnyHit | TRACE_ComplexCollision, FVector (0.f,0.f,0.f) )\n              && !IsRelevantThroughPortals ( RealViewer) )\n         {\n              UBOOL RealViewerCanSeeThis = TRUE;\n              APawn * RealViewerPawn = RealViewer ->Pawn ;\n              if (NULL != RealViewerPawn)\n             {\n                  RealViewerCanSeeThis = GWorld ->SingleLineCheck ( Hit, this , RealViewerPawn ->Location + FVector (0.f,0.f,RealViewerPawn -> BaseEyeHeight), Location , TRACE_World |TRACE_StopAtAnyHit | TRACE_ComplexCollision, FVector (0.f,0.f,0.f));\n             }\n              if (RealViewerCanSeeThis )\n                  return CacheNetRelevancy (TRUE , RealViewer, Viewer );\n              else\n                  return CacheNetRelevancy (FALSE , RealViewer, Viewer );\n         }\n          return CacheNetRelevancy (TRUE , RealViewer, Viewer );\n    }\n}\n```","slug":"Pawn的Relevancy（关联）Checklist分析（基于虚幻3）","published":1,"updated":"2016-11-26T12:34:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlvoa2k0002jtu3hbq3it38","content":"<p>在项目开发中，我发现了游戏中有一个bug。怪物会无端端消失，移动一下玩家角色，怪物又会重新出现。特别是在玩家角色前面有遮挡物的时候，很容易重现。不难猜想，就是虚幻的关联导致的这个现象，因此唯有对Pawn的关联的检查流程仔细分析。<br>追根溯源，最后终于定位到了如下函数：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3713845-7cd88fe288a20426.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Pawn的关联判断函数.png\"></p>\n<p>这个函数具体实现如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">UBOOL APawn ::IsNetRelevantFor( APlayerController* RealViewer, AActor * Viewer, const FVector &amp; SrcLocation)</div><div class=\"line\">&#123;</div><div class=\"line\">     if ( bAlwaysRelevant )</div><div class=\"line\">          return TRUE ;</div><div class=\"line\">     if ( (NetRelevancyTime == GWorld-&gt;GetTimeSeconds ()) &amp;&amp; (RealViewer == LastRealViewer) &amp;&amp; (Viewer == LastViewer) )</div><div class=\"line\">    &#123;</div><div class=\"line\">          return bCachedRelevant ;</div><div class=\"line\">    &#125;</div><div class=\"line\">     if( IsOwnedBy (Viewer) || IsOwnedBy(RealViewer ) || this==Viewer || Viewer== Instigator</div><div class=\"line\">         || IsBasedOn(Viewer ) || (Viewer &amp;&amp; Viewer-&gt;IsBasedOn (this)) || RealViewer-&gt;bReplicateAllPawns</div><div class=\"line\">         || ( Controller &amp;&amp; ((Location - Viewer-&gt;Location ).SizeSquared() &lt; AlwaysRelevantDistanceSquared )) || HasAudibleAmbientSound(SrcLocation ) )</div><div class=\"line\">          return CacheNetRelevancy(TRUE ,RealViewer, Viewer);</div><div class=\"line\">     else if ( (bHidden || bOnlyOwnerSee) &amp;&amp; !bBlockActors )</div><div class=\"line\">          return CacheNetRelevancy(FALSE ,RealViewer, Viewer);</div><div class=\"line\">     else if ( Base &amp;&amp; ( BaseSkelComponent || ((Base == Owner) &amp;&amp; !bOnlyOwnerSee )) )</div><div class=\"line\">          return Base -&gt;IsNetRelevantFor( RealViewer, Viewer, SrcLocation );</div><div class=\"line\">     else</div><div class=\"line\">    &#123;</div><div class=\"line\">#ifdef USE_DISTANCE_FOG_OCCLUSION</div><div class=\"line\">          // check distance fog</div><div class=\"line\">          if ( RealViewer-&gt;BeyondFogDistance (SrcLocation, Location) )</div><div class=\"line\">              return CacheNetRelevancy(false ,RealViewer, Viewer);</div><div class=\"line\">#endif</div><div class=\"line\">          // check against BSP - check head and center</div><div class=\"line\">          //debugf(TEXT(&quot;Check relevance of %s&quot;),*(PlayerReplicationInfo-&gt;PlayerName));</div><div class=\"line\">          FCheckResult Hit (1.f);</div><div class=\"line\">          if ( !GWorld -&gt;SingleLineCheck( Hit, this , Location + FVector (0.f,0.f,BaseEyeHeight), SrcLocation, TRACE_World|TRACE_StopAtAnyHit |TRACE_ComplexCollision, FVector(0.f,0.f,0.f) )</div><div class=\"line\">             &amp;&amp; ! GWorld-&gt;SingleLineCheck ( Hit, this, Location, SrcLocation , TRACE_World|TRACE_StopAtAnyHit |TRACE_ComplexCollision, FVector(0.f,0.f,0.f) )</div><div class=\"line\">             &amp;&amp; !IsRelevantThroughPortals (RealViewer) )</div><div class=\"line\">         &#123;</div><div class=\"line\">              return CacheNetRelevancy(FALSE ,RealViewer, Viewer);</div><div class=\"line\">         &#125;</div><div class=\"line\">          return CacheNetRelevancy(TRUE ,RealViewer, Viewer);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到，Pawn的关联判断流程：<br>1、先判断是否是bAlwaysRelevant，如果是，则直接返回true<br>2、判断是否已经检查过了，是则直接返回上一次检查结果<br>3、判断以下条件，有一个成立则认为是关联：<br>           是否被Viewer拥有，<br>           是否被RealViewer拥有，是否viewer就是自己本身，<br>           viewer是否是本身的Instigator（注意，Instigator 和 owner不要混淆了哦），<br>           是否base on viewer或者是viewer base on自己，<br>           是否RealViewer的bReplicateAllPawns为true，<br>           自己和viewer是否在一定会关联的距离内，<br>           是否会听到目标位置的声音<br>4、判断 ( (bHidden || bOnlyOwnerSee) &amp;&amp; !bBlockActors )，不能被碰撞，而且被隐藏了或者自由owner能看见。<br>5、判断是否有base，有的话检查base是否是关联的，如果base是关联，则这个pawn也是关联的。<br>6、以下条件任何一个成立，则返回不关联<br>            通过线性检测，检测到这个Pawn的眼睛的位置和SrcLocation之间有遮挡（SrcLocation 可以理解为Viewer的location，当然为了更好的体验感，其实还增加了预判，具体的实现在FNetViewer::FNetViewer()函数中）；<br>            这个Pawn的位置和SrcLocation之间有遮挡；<br>            不能通过某个房间的入口看得到RealViewer（通过遍历检查RealViewer::VisiblePortals的成员实现。TickSpecial()会不断调用CheckPortalVisible()更新Controller中的VisiblePortals）；</p>\n<p>问题就出在第6个条件那里。<br>这个Pawn就是要判断是否关联的怪物，而第六个条件只是判断了：怪物的眼睛到玩家的位置做射线检测、怪物的位置到玩家的位置做射线检测 ，但是，玩家的眼睛的位置到怪物的位置这个射线检测没有判断，因此如果怪物检测不到玩家，而玩家却刚好能看得到怪物的时候，就会出现这个怪物不关联的bug了。<br>知道问题，改起来也简单，增加一个射线检测就行了。上面的函数改为下面这样，就OK了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">UBOOL APawn :: IsNetRelevantFor( APlayerController * RealViewer , AActor * Viewer, const FVector &amp; SrcLocation )</div><div class=\"line\">&#123;</div><div class=\"line\">     if ( bAlwaysRelevant )</div><div class=\"line\">          return TRUE ;</div><div class=\"line\">     if ( (NetRelevancyTime == GWorld -&gt;GetTimeSeconds ()) &amp;&amp; ( RealViewer == LastRealViewer ) &amp;&amp; (Viewer == LastViewer) )</div><div class=\"line\">    &#123;</div><div class=\"line\">          return bCachedRelevant ;</div><div class=\"line\">    &#125;</div><div class=\"line\">     if ( IsOwnedBy ( Viewer) || IsOwnedBy (RealViewer ) || this ==Viewer || Viewer== Instigator</div><div class=\"line\">         || IsBasedOn (Viewer ) || ( Viewer &amp;&amp; Viewer -&gt;IsBasedOn ( this)) || RealViewer -&gt;bReplicateAllPawns</div><div class=\"line\"></div><div class=\"line\">         || ( Controller &amp;&amp; ((Location - Viewer -&gt;Location ). SizeSquared() &lt; AlwaysRelevantDistanceSquared )) || HasAudibleAmbientSound (SrcLocation ) )</div><div class=\"line\">          return CacheNetRelevancy (TRUE , RealViewer, Viewer );</div><div class=\"line\">     else if ( ( bHidden || bOnlyOwnerSee ) &amp;&amp; !bBlockActors )</div><div class=\"line\">          return CacheNetRelevancy (FALSE , RealViewer, Viewer );</div><div class=\"line\">     else if ( Base &amp;&amp; ( BaseSkelComponent || ((Base == Owner ) &amp;&amp; !bOnlyOwnerSee )) )</div><div class=\"line\">          return Base -&gt; IsNetRelevantFor( RealViewer , Viewer , SrcLocation );</div><div class=\"line\">     else</div><div class=\"line\">    &#123;</div><div class=\"line\">#ifdef USE_DISTANCE_FOG_OCCLUSION</div><div class=\"line\">          // check distance fog</div><div class=\"line\">          if ( RealViewer -&gt;BeyondFogDistance ( SrcLocation, Location ) )</div><div class=\"line\">              return CacheNetRelevancy (false , RealViewer, Viewer );</div><div class=\"line\">#endif</div><div class=\"line\">          // check against BSP - check head and center</div><div class=\"line\">          //debugf(TEXT(&quot;Check relevance of %s&quot;),*(PlayerReplicationInfo-&gt;PlayerName));</div><div class=\"line\">          FCheckResult Hit (1.f);</div><div class=\"line\">          if ( !GWorld -&gt; SingleLineCheck( Hit , this , Location + FVector (0.f,0.f, BaseEyeHeight), SrcLocation , TRACE_World |TRACE_StopAtAnyHit | TRACE_ComplexCollision, FVector (0.f,0.f,0.f) )</div><div class=\"line\">             &amp;&amp; ! GWorld -&gt;SingleLineCheck ( Hit, this , Location , SrcLocation , TRACE_World |TRACE_StopAtAnyHit | TRACE_ComplexCollision, FVector (0.f,0.f,0.f) )</div><div class=\"line\">              &amp;&amp; !IsRelevantThroughPortals ( RealViewer) )</div><div class=\"line\">         &#123;</div><div class=\"line\">              UBOOL RealViewerCanSeeThis = TRUE;</div><div class=\"line\">              APawn * RealViewerPawn = RealViewer -&gt;Pawn ;</div><div class=\"line\">              if (NULL != RealViewerPawn)</div><div class=\"line\">             &#123;</div><div class=\"line\">                  RealViewerCanSeeThis = GWorld -&gt;SingleLineCheck ( Hit, this , RealViewerPawn -&gt;Location + FVector (0.f,0.f,RealViewerPawn -&gt; BaseEyeHeight), Location , TRACE_World |TRACE_StopAtAnyHit | TRACE_ComplexCollision, FVector (0.f,0.f,0.f));</div><div class=\"line\">             &#125;</div><div class=\"line\">              if (RealViewerCanSeeThis )</div><div class=\"line\">                  return CacheNetRelevancy (TRUE , RealViewer, Viewer );</div><div class=\"line\">              else</div><div class=\"line\">                  return CacheNetRelevancy (FALSE , RealViewer, Viewer );</div><div class=\"line\">         &#125;</div><div class=\"line\">          return CacheNetRelevancy (TRUE , RealViewer, Viewer );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","excerpt":"","more":"<p>在项目开发中，我发现了游戏中有一个bug。怪物会无端端消失，移动一下玩家角色，怪物又会重新出现。特别是在玩家角色前面有遮挡物的时候，很容易重现。不难猜想，就是虚幻的关联导致的这个现象，因此唯有对Pawn的关联的检查流程仔细分析。<br>追根溯源，最后终于定位到了如下函数：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3713845-7cd88fe288a20426.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Pawn的关联判断函数.png\"></p>\n<p>这个函数具体实现如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">UBOOL APawn ::IsNetRelevantFor( APlayerController* RealViewer, AActor * Viewer, const FVector &amp; SrcLocation)</div><div class=\"line\">&#123;</div><div class=\"line\">     if ( bAlwaysRelevant )</div><div class=\"line\">          return TRUE ;</div><div class=\"line\">     if ( (NetRelevancyTime == GWorld-&gt;GetTimeSeconds ()) &amp;&amp; (RealViewer == LastRealViewer) &amp;&amp; (Viewer == LastViewer) )</div><div class=\"line\">    &#123;</div><div class=\"line\">          return bCachedRelevant ;</div><div class=\"line\">    &#125;</div><div class=\"line\">     if( IsOwnedBy (Viewer) || IsOwnedBy(RealViewer ) || this==Viewer || Viewer== Instigator</div><div class=\"line\">         || IsBasedOn(Viewer ) || (Viewer &amp;&amp; Viewer-&gt;IsBasedOn (this)) || RealViewer-&gt;bReplicateAllPawns</div><div class=\"line\">         || ( Controller &amp;&amp; ((Location - Viewer-&gt;Location ).SizeSquared() &lt; AlwaysRelevantDistanceSquared )) || HasAudibleAmbientSound(SrcLocation ) )</div><div class=\"line\">          return CacheNetRelevancy(TRUE ,RealViewer, Viewer);</div><div class=\"line\">     else if ( (bHidden || bOnlyOwnerSee) &amp;&amp; !bBlockActors )</div><div class=\"line\">          return CacheNetRelevancy(FALSE ,RealViewer, Viewer);</div><div class=\"line\">     else if ( Base &amp;&amp; ( BaseSkelComponent || ((Base == Owner) &amp;&amp; !bOnlyOwnerSee )) )</div><div class=\"line\">          return Base -&gt;IsNetRelevantFor( RealViewer, Viewer, SrcLocation );</div><div class=\"line\">     else</div><div class=\"line\">    &#123;</div><div class=\"line\">#ifdef USE_DISTANCE_FOG_OCCLUSION</div><div class=\"line\">          // check distance fog</div><div class=\"line\">          if ( RealViewer-&gt;BeyondFogDistance (SrcLocation, Location) )</div><div class=\"line\">              return CacheNetRelevancy(false ,RealViewer, Viewer);</div><div class=\"line\">#endif</div><div class=\"line\">          // check against BSP - check head and center</div><div class=\"line\">          //debugf(TEXT(&quot;Check relevance of %s&quot;),*(PlayerReplicationInfo-&gt;PlayerName));</div><div class=\"line\">          FCheckResult Hit (1.f);</div><div class=\"line\">          if ( !GWorld -&gt;SingleLineCheck( Hit, this , Location + FVector (0.f,0.f,BaseEyeHeight), SrcLocation, TRACE_World|TRACE_StopAtAnyHit |TRACE_ComplexCollision, FVector(0.f,0.f,0.f) )</div><div class=\"line\">             &amp;&amp; ! GWorld-&gt;SingleLineCheck ( Hit, this, Location, SrcLocation , TRACE_World|TRACE_StopAtAnyHit |TRACE_ComplexCollision, FVector(0.f,0.f,0.f) )</div><div class=\"line\">             &amp;&amp; !IsRelevantThroughPortals (RealViewer) )</div><div class=\"line\">         &#123;</div><div class=\"line\">              return CacheNetRelevancy(FALSE ,RealViewer, Viewer);</div><div class=\"line\">         &#125;</div><div class=\"line\">          return CacheNetRelevancy(TRUE ,RealViewer, Viewer);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到，Pawn的关联判断流程：<br>1、先判断是否是bAlwaysRelevant，如果是，则直接返回true<br>2、判断是否已经检查过了，是则直接返回上一次检查结果<br>3、判断以下条件，有一个成立则认为是关联：<br>           是否被Viewer拥有，<br>           是否被RealViewer拥有，是否viewer就是自己本身，<br>           viewer是否是本身的Instigator（注意，Instigator 和 owner不要混淆了哦），<br>           是否base on viewer或者是viewer base on自己，<br>           是否RealViewer的bReplicateAllPawns为true，<br>           自己和viewer是否在一定会关联的距离内，<br>           是否会听到目标位置的声音<br>4、判断 ( (bHidden || bOnlyOwnerSee) &amp;&amp; !bBlockActors )，不能被碰撞，而且被隐藏了或者自由owner能看见。<br>5、判断是否有base，有的话检查base是否是关联的，如果base是关联，则这个pawn也是关联的。<br>6、以下条件任何一个成立，则返回不关联<br>            通过线性检测，检测到这个Pawn的眼睛的位置和SrcLocation之间有遮挡（SrcLocation 可以理解为Viewer的location，当然为了更好的体验感，其实还增加了预判，具体的实现在FNetViewer::FNetViewer()函数中）；<br>            这个Pawn的位置和SrcLocation之间有遮挡；<br>            不能通过某个房间的入口看得到RealViewer（通过遍历检查RealViewer::VisiblePortals的成员实现。TickSpecial()会不断调用CheckPortalVisible()更新Controller中的VisiblePortals）；</p>\n<p>问题就出在第6个条件那里。<br>这个Pawn就是要判断是否关联的怪物，而第六个条件只是判断了：怪物的眼睛到玩家的位置做射线检测、怪物的位置到玩家的位置做射线检测 ，但是，玩家的眼睛的位置到怪物的位置这个射线检测没有判断，因此如果怪物检测不到玩家，而玩家却刚好能看得到怪物的时候，就会出现这个怪物不关联的bug了。<br>知道问题，改起来也简单，增加一个射线检测就行了。上面的函数改为下面这样，就OK了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">UBOOL APawn :: IsNetRelevantFor( APlayerController * RealViewer , AActor * Viewer, const FVector &amp; SrcLocation )</div><div class=\"line\">&#123;</div><div class=\"line\">     if ( bAlwaysRelevant )</div><div class=\"line\">          return TRUE ;</div><div class=\"line\">     if ( (NetRelevancyTime == GWorld -&gt;GetTimeSeconds ()) &amp;&amp; ( RealViewer == LastRealViewer ) &amp;&amp; (Viewer == LastViewer) )</div><div class=\"line\">    &#123;</div><div class=\"line\">          return bCachedRelevant ;</div><div class=\"line\">    &#125;</div><div class=\"line\">     if ( IsOwnedBy ( Viewer) || IsOwnedBy (RealViewer ) || this ==Viewer || Viewer== Instigator</div><div class=\"line\">         || IsBasedOn (Viewer ) || ( Viewer &amp;&amp; Viewer -&gt;IsBasedOn ( this)) || RealViewer -&gt;bReplicateAllPawns</div><div class=\"line\"></div><div class=\"line\">         || ( Controller &amp;&amp; ((Location - Viewer -&gt;Location ). SizeSquared() &lt; AlwaysRelevantDistanceSquared )) || HasAudibleAmbientSound (SrcLocation ) )</div><div class=\"line\">          return CacheNetRelevancy (TRUE , RealViewer, Viewer );</div><div class=\"line\">     else if ( ( bHidden || bOnlyOwnerSee ) &amp;&amp; !bBlockActors )</div><div class=\"line\">          return CacheNetRelevancy (FALSE , RealViewer, Viewer );</div><div class=\"line\">     else if ( Base &amp;&amp; ( BaseSkelComponent || ((Base == Owner ) &amp;&amp; !bOnlyOwnerSee )) )</div><div class=\"line\">          return Base -&gt; IsNetRelevantFor( RealViewer , Viewer , SrcLocation );</div><div class=\"line\">     else</div><div class=\"line\">    &#123;</div><div class=\"line\">#ifdef USE_DISTANCE_FOG_OCCLUSION</div><div class=\"line\">          // check distance fog</div><div class=\"line\">          if ( RealViewer -&gt;BeyondFogDistance ( SrcLocation, Location ) )</div><div class=\"line\">              return CacheNetRelevancy (false , RealViewer, Viewer );</div><div class=\"line\">#endif</div><div class=\"line\">          // check against BSP - check head and center</div><div class=\"line\">          //debugf(TEXT(&quot;Check relevance of %s&quot;),*(PlayerReplicationInfo-&gt;PlayerName));</div><div class=\"line\">          FCheckResult Hit (1.f);</div><div class=\"line\">          if ( !GWorld -&gt; SingleLineCheck( Hit , this , Location + FVector (0.f,0.f, BaseEyeHeight), SrcLocation , TRACE_World |TRACE_StopAtAnyHit | TRACE_ComplexCollision, FVector (0.f,0.f,0.f) )</div><div class=\"line\">             &amp;&amp; ! GWorld -&gt;SingleLineCheck ( Hit, this , Location , SrcLocation , TRACE_World |TRACE_StopAtAnyHit | TRACE_ComplexCollision, FVector (0.f,0.f,0.f) )</div><div class=\"line\">              &amp;&amp; !IsRelevantThroughPortals ( RealViewer) )</div><div class=\"line\">         &#123;</div><div class=\"line\">              UBOOL RealViewerCanSeeThis = TRUE;</div><div class=\"line\">              APawn * RealViewerPawn = RealViewer -&gt;Pawn ;</div><div class=\"line\">              if (NULL != RealViewerPawn)</div><div class=\"line\">             &#123;</div><div class=\"line\">                  RealViewerCanSeeThis = GWorld -&gt;SingleLineCheck ( Hit, this , RealViewerPawn -&gt;Location + FVector (0.f,0.f,RealViewerPawn -&gt; BaseEyeHeight), Location , TRACE_World |TRACE_StopAtAnyHit | TRACE_ComplexCollision, FVector (0.f,0.f,0.f));</div><div class=\"line\">             &#125;</div><div class=\"line\">              if (RealViewerCanSeeThis )</div><div class=\"line\">                  return CacheNetRelevancy (TRUE , RealViewer, Viewer );</div><div class=\"line\">              else</div><div class=\"line\">                  return CacheNetRelevancy (FALSE , RealViewer, Viewer );</div><div class=\"line\">         &#125;</div><div class=\"line\">          return CacheNetRelevancy (TRUE , RealViewer, Viewer );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"SeqEvent_Touch实现原理概要","date":"2016-11-26T09:39:52.000Z","_content":"\nSeqEvent_Touch是kismet的事件节点，Actor被触摸的时候触发。\n\n# Actor的SupportdEvents和GeneratedEvents数组\n\n\n如图，Actor下有两个数组：SupportdEvents和GeneratedEvents。\n![](http://upload-images.jianshu.io/upload_images/3713845-98757182b3d66e44.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n1. SupportdEvents是此Actor支持的事件，一般在defaultproperties被初始化。如果需要支持SeqEvent_Touch，则必须加上。\n2. GeneratedEvents则保存了发生关联的事件。\n在关卡启动，kismet序列被初始化的时候，会将事件添加到对应的Originator的GeneratedEvents数组。具体逻辑的主要函数如下：\n![](http://upload-images.jianshu.io/upload_images/3713845-376271e0dad18c8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![](http://upload-images.jianshu.io/upload_images/3713845-b5831331d80cf876.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![](http://upload-images.jianshu.io/upload_images/3713845-c9eba499a888e50d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![](http://upload-images.jianshu.io/upload_images/3713845-842d4346e766fc75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\nUSequeneceEvent是SeqEvent_Touch的父类。而事件就是在RegisterEvent()函数与对应的Originator关联起来的。\n\n# Actor被Touch后的逻辑\nSeqEvent_Touch有如下几个cpp函数，从函数名字面不难理解其实现的主要功能：\n![](http://upload-images.jianshu.io/upload_images/3713845-d148ad3aefe09440.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n当Actor被触摸后，会执行到下图的函数，可以看到，这个函数找到Actor所关联的所有SeqEvent_Touch事件，执行它的CheckTouchActivate()函数。然后执行eventTouch()，也就是unrealscript中的Touch函数。\n![](http://upload-images.jianshu.io/upload_images/3713845-1f4441ba412e8dae.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)","source":"_posts/SeqEvent-Touch实现原理概要.md","raw":"---\ntitle: SeqEvent_Touch实现原理概要\ndate: 2016-11-26 17:39:52\ncategories: 虚幻3\ntags:\n---\n\nSeqEvent_Touch是kismet的事件节点，Actor被触摸的时候触发。\n\n# Actor的SupportdEvents和GeneratedEvents数组\n\n\n如图，Actor下有两个数组：SupportdEvents和GeneratedEvents。\n![](http://upload-images.jianshu.io/upload_images/3713845-98757182b3d66e44.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n1. SupportdEvents是此Actor支持的事件，一般在defaultproperties被初始化。如果需要支持SeqEvent_Touch，则必须加上。\n2. GeneratedEvents则保存了发生关联的事件。\n在关卡启动，kismet序列被初始化的时候，会将事件添加到对应的Originator的GeneratedEvents数组。具体逻辑的主要函数如下：\n![](http://upload-images.jianshu.io/upload_images/3713845-376271e0dad18c8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![](http://upload-images.jianshu.io/upload_images/3713845-b5831331d80cf876.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![](http://upload-images.jianshu.io/upload_images/3713845-c9eba499a888e50d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![](http://upload-images.jianshu.io/upload_images/3713845-842d4346e766fc75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\nUSequeneceEvent是SeqEvent_Touch的父类。而事件就是在RegisterEvent()函数与对应的Originator关联起来的。\n\n# Actor被Touch后的逻辑\nSeqEvent_Touch有如下几个cpp函数，从函数名字面不难理解其实现的主要功能：\n![](http://upload-images.jianshu.io/upload_images/3713845-d148ad3aefe09440.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n当Actor被触摸后，会执行到下图的函数，可以看到，这个函数找到Actor所关联的所有SeqEvent_Touch事件，执行它的CheckTouchActivate()函数。然后执行eventTouch()，也就是unrealscript中的Touch函数。\n![](http://upload-images.jianshu.io/upload_images/3713845-1f4441ba412e8dae.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)","slug":"SeqEvent-Touch实现原理概要","published":1,"updated":"2016-11-26T12:34:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlvoa2r0005jtu3sqgmvxaq","content":"<p>SeqEvent_Touch是kismet的事件节点，Actor被触摸的时候触发。</p>\n<h1 id=\"Actor的SupportdEvents和GeneratedEvents数组\"><a href=\"#Actor的SupportdEvents和GeneratedEvents数组\" class=\"headerlink\" title=\"Actor的SupportdEvents和GeneratedEvents数组\"></a>Actor的SupportdEvents和GeneratedEvents数组</h1><p>如图，Actor下有两个数组：SupportdEvents和GeneratedEvents。<br><img src=\"http://upload-images.jianshu.io/upload_images/3713845-98757182b3d66e44.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<ol>\n<li>SupportdEvents是此Actor支持的事件，一般在defaultproperties被初始化。如果需要支持SeqEvent_Touch，则必须加上。</li>\n<li>GeneratedEvents则保存了发生关联的事件。<br>在关卡启动，kismet序列被初始化的时候，会将事件添加到对应的Originator的GeneratedEvents数组。具体逻辑的主要函数如下：<br><img src=\"http://upload-images.jianshu.io/upload_images/3713845-376271e0dad18c8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br><img src=\"http://upload-images.jianshu.io/upload_images/3713845-b5831331d80cf876.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br><img src=\"http://upload-images.jianshu.io/upload_images/3713845-c9eba499a888e50d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br><img src=\"http://upload-images.jianshu.io/upload_images/3713845-842d4346e766fc75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>USequeneceEvent是SeqEvent_Touch的父类。而事件就是在RegisterEvent()函数与对应的Originator关联起来的。</li>\n</ol>\n<h1 id=\"Actor被Touch后的逻辑\"><a href=\"#Actor被Touch后的逻辑\" class=\"headerlink\" title=\"Actor被Touch后的逻辑\"></a>Actor被Touch后的逻辑</h1><p>SeqEvent_Touch有如下几个cpp函数，从函数名字面不难理解其实现的主要功能：<br><img src=\"http://upload-images.jianshu.io/upload_images/3713845-d148ad3aefe09440.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>当Actor被触摸后，会执行到下图的函数，可以看到，这个函数找到Actor所关联的所有SeqEvent_Touch事件，执行它的CheckTouchActivate()函数。然后执行eventTouch()，也就是unrealscript中的Touch函数。<br><img src=\"http://upload-images.jianshu.io/upload_images/3713845-1f4441ba412e8dae.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n","excerpt":"","more":"<p>SeqEvent_Touch是kismet的事件节点，Actor被触摸的时候触发。</p>\n<h1 id=\"Actor的SupportdEvents和GeneratedEvents数组\"><a href=\"#Actor的SupportdEvents和GeneratedEvents数组\" class=\"headerlink\" title=\"Actor的SupportdEvents和GeneratedEvents数组\"></a>Actor的SupportdEvents和GeneratedEvents数组</h1><p>如图，Actor下有两个数组：SupportdEvents和GeneratedEvents。<br><img src=\"http://upload-images.jianshu.io/upload_images/3713845-98757182b3d66e44.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<ol>\n<li>SupportdEvents是此Actor支持的事件，一般在defaultproperties被初始化。如果需要支持SeqEvent_Touch，则必须加上。</li>\n<li>GeneratedEvents则保存了发生关联的事件。<br>在关卡启动，kismet序列被初始化的时候，会将事件添加到对应的Originator的GeneratedEvents数组。具体逻辑的主要函数如下：<br><img src=\"http://upload-images.jianshu.io/upload_images/3713845-376271e0dad18c8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br><img src=\"http://upload-images.jianshu.io/upload_images/3713845-b5831331d80cf876.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br><img src=\"http://upload-images.jianshu.io/upload_images/3713845-c9eba499a888e50d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br><img src=\"http://upload-images.jianshu.io/upload_images/3713845-842d4346e766fc75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>USequeneceEvent是SeqEvent_Touch的父类。而事件就是在RegisterEvent()函数与对应的Originator关联起来的。</li>\n</ol>\n<h1 id=\"Actor被Touch后的逻辑\"><a href=\"#Actor被Touch后的逻辑\" class=\"headerlink\" title=\"Actor被Touch后的逻辑\"></a>Actor被Touch后的逻辑</h1><p>SeqEvent_Touch有如下几个cpp函数，从函数名字面不难理解其实现的主要功能：<br><img src=\"http://upload-images.jianshu.io/upload_images/3713845-d148ad3aefe09440.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>当Actor被触摸后，会执行到下图的函数，可以看到，这个函数找到Actor所关联的所有SeqEvent_Touch事件，执行它的CheckTouchActivate()函数。然后执行eventTouch()，也就是unrealscript中的Touch函数。<br><img src=\"http://upload-images.jianshu.io/upload_images/3713845-1f4441ba412e8dae.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n"},{"title":"行为树基础","date":"2016-12-08T14:41:22.000Z","_content":"","source":"_posts/行为树基础.md","raw":"---\ntitle: 行为树基础\ndate: 2016-12-08 22:41:22\ntags:\ncategories: Behavior Tree\n---\n","slug":"行为树基础","published":1,"updated":"2017-01-06T12:39:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlvoa2v0006jtu3ugpuoiot","content":"","excerpt":"","more":""},{"title":"UTGame武器开火流程","date":"2016-11-26T09:36:34.000Z","_content":"\n| 执行的对象 | 本地客户端 | Server | 其他玩家客户端 |\n|:-----------| :----------- | :----------- | :-----------:|\n| playerController| StartFire() | ||\n| UTPawn | StartFire()| ||\n| Weapon(LinkGun) |StartFire()<br>StartFire主要做了两件事：<br>1. 本地直接执行BeginFire()<br>2. 如果是网络游戏会远程调用ServerStartFire()      | ||\n| Weapon(LinkGun) | BeginFire()<br>注意，此时Weapon的状态是Active，执行的是状态机里面的BeginFire()函数。<br>这里主要做了两件事：<br>1. 调用Global.BeginFire()。<br>这个函数调用了SetPendingFire()，而转而调用了InventoryManager的SetPendingFire()，这个函数只有一行代码：PendingFire[InFiringMode] = 1;将这个值设为1，主要是用来记录开火模式，鼠标左右键有不同开火模式。<br>2. 如果能开火，调用SendToFiringState()。<br>这个函数设置了开火模式（UTPawn的SetFiringMode()函数），然后跳转到开火状态WeaponFiring。<br>3. UTWeapon重写了这个BeginFire，并加入了checkRoom()功能，主要用在狙击枪开镜，这里不展开了，其实就是修改FOV视角。|ServerStartFire()<br>主要是做了一件事：<br>执行BeginFire()。与本地客户端相同。||\n| Weapon(LinkGun) | 进入WeaponFiring状态，执行BeginState()。<br>这个函数做了两件事：<br>1. FireAmmunition()<br>这个函数也是干了两件事<br>（1)ConsumeAmmo()<br>消耗子弹。<br>（2）根据子弹类型调用不同逻辑，在这里以EWFT_Projectile为例，则执行ProjectileFire()。<br>ProjectileFire()主要做两件事：<br>  IncrementFlashCount()<br>     这个函数调用了UTPawn的IncrementFlashCount()函数。后面两行继续详细分析。<br> - 因为是客户端，所以不会执行这件事。（Spawn子弹）。<br>2. TimeWeaponFiring()<br>这个函数是两次开枪时间间隔相关的计时。| 1. 这里与本地客户端唯一区别就是ProjectileFire()函数，服务器还会做一件事情就是：创建子弹。<br>2. 创建子弹流程如下：<br>a) 调用Instigator的GetWeaponStartTraceLocation函数。如果Instigator有controller，这函数会返回controller的location，不然就返回它自己眼睛的位置，StartTrace。<br>b)    获得发射方向。GetAdjustedAim函数是一系列让weapon, the pawn and the controller调整子弹发射方向的处理的开始。它调用 了Pawn(如果有)的GetAdjustedAimFor()，然后调用AddSpread()增加散射调整后return最终的角度。Pawn的GetAdjustedAimFor()。<br>如果Pawn没有controller，则返回GetBaseAimRotation()的计算结果，否则调用controller的GetAdjustedAimFor()，让controller调整角度。<br>c)   调用GetPhysicalFireStartLoc()获得子弹的创建位置（一般是枪口位置）<br>d) 如果子弹创建位置和StartTrace不相等，那么需要根据用StartTrace、发射方向、射程来做射线检测，预测子弹的碰撞，CalcWeaponFire()，据碰撞点和子弹创建位置求得新的发射方向。<br>e)  Spawn子弹并init。||\n| UTPawn | IncrementFlashCount()<br>这个函数修改了FlashCount，再次设置SetFiringMode()保证开火模式正确，然后执行FlashCountUpdated()函数，FlashCountUpdated()函数会判断FlashCount，如果FlashCount>0，那么执行WeaponFired()，否则WeaponStoppedFiring()。|逻辑和本地客户端一样。<br>此外，因为FlashCount这个值是repnotify修饰的，所以会复制到其他客户端。||\n|UTPawn |WeaponFired()<br>这个函数主要是利用WeaponAttachment播放开火特效、角色动画、音效等。| |FlashCount的改变被复制下来，并执行ReplicatedEvent，这个函数内这时会根据参数名调用FlashCountUpdated函数。|\n|UTPawn | | | WeaponFired()函数 |\n\n上表描述便是主要的UTGame开火流程。\nPS：关于子弹Projectile：\nProjectile的物理相关属性中，bCollideWord被设为true（表示物体是否与关卡几何（CSG）发生collide。），因此，击中关卡中的物体的时候，会调用HitWall事件，进而调用TakeDamage()函数。\n\n居然吐着血，耐着markdown难用的表格写下来了。。。","source":"_posts/UTGame武器开火流程.md","raw":"---\ntitle: UTGame武器开火流程\ndate: 2016-11-26 17:36:34\ncategories: 虚幻3\ntags:\n---\n\n| 执行的对象 | 本地客户端 | Server | 其他玩家客户端 |\n|:-----------| :----------- | :----------- | :-----------:|\n| playerController| StartFire() | ||\n| UTPawn | StartFire()| ||\n| Weapon(LinkGun) |StartFire()<br>StartFire主要做了两件事：<br>1. 本地直接执行BeginFire()<br>2. 如果是网络游戏会远程调用ServerStartFire()      | ||\n| Weapon(LinkGun) | BeginFire()<br>注意，此时Weapon的状态是Active，执行的是状态机里面的BeginFire()函数。<br>这里主要做了两件事：<br>1. 调用Global.BeginFire()。<br>这个函数调用了SetPendingFire()，而转而调用了InventoryManager的SetPendingFire()，这个函数只有一行代码：PendingFire[InFiringMode] = 1;将这个值设为1，主要是用来记录开火模式，鼠标左右键有不同开火模式。<br>2. 如果能开火，调用SendToFiringState()。<br>这个函数设置了开火模式（UTPawn的SetFiringMode()函数），然后跳转到开火状态WeaponFiring。<br>3. UTWeapon重写了这个BeginFire，并加入了checkRoom()功能，主要用在狙击枪开镜，这里不展开了，其实就是修改FOV视角。|ServerStartFire()<br>主要是做了一件事：<br>执行BeginFire()。与本地客户端相同。||\n| Weapon(LinkGun) | 进入WeaponFiring状态，执行BeginState()。<br>这个函数做了两件事：<br>1. FireAmmunition()<br>这个函数也是干了两件事<br>（1)ConsumeAmmo()<br>消耗子弹。<br>（2）根据子弹类型调用不同逻辑，在这里以EWFT_Projectile为例，则执行ProjectileFire()。<br>ProjectileFire()主要做两件事：<br>  IncrementFlashCount()<br>     这个函数调用了UTPawn的IncrementFlashCount()函数。后面两行继续详细分析。<br> - 因为是客户端，所以不会执行这件事。（Spawn子弹）。<br>2. TimeWeaponFiring()<br>这个函数是两次开枪时间间隔相关的计时。| 1. 这里与本地客户端唯一区别就是ProjectileFire()函数，服务器还会做一件事情就是：创建子弹。<br>2. 创建子弹流程如下：<br>a) 调用Instigator的GetWeaponStartTraceLocation函数。如果Instigator有controller，这函数会返回controller的location，不然就返回它自己眼睛的位置，StartTrace。<br>b)    获得发射方向。GetAdjustedAim函数是一系列让weapon, the pawn and the controller调整子弹发射方向的处理的开始。它调用 了Pawn(如果有)的GetAdjustedAimFor()，然后调用AddSpread()增加散射调整后return最终的角度。Pawn的GetAdjustedAimFor()。<br>如果Pawn没有controller，则返回GetBaseAimRotation()的计算结果，否则调用controller的GetAdjustedAimFor()，让controller调整角度。<br>c)   调用GetPhysicalFireStartLoc()获得子弹的创建位置（一般是枪口位置）<br>d) 如果子弹创建位置和StartTrace不相等，那么需要根据用StartTrace、发射方向、射程来做射线检测，预测子弹的碰撞，CalcWeaponFire()，据碰撞点和子弹创建位置求得新的发射方向。<br>e)  Spawn子弹并init。||\n| UTPawn | IncrementFlashCount()<br>这个函数修改了FlashCount，再次设置SetFiringMode()保证开火模式正确，然后执行FlashCountUpdated()函数，FlashCountUpdated()函数会判断FlashCount，如果FlashCount>0，那么执行WeaponFired()，否则WeaponStoppedFiring()。|逻辑和本地客户端一样。<br>此外，因为FlashCount这个值是repnotify修饰的，所以会复制到其他客户端。||\n|UTPawn |WeaponFired()<br>这个函数主要是利用WeaponAttachment播放开火特效、角色动画、音效等。| |FlashCount的改变被复制下来，并执行ReplicatedEvent，这个函数内这时会根据参数名调用FlashCountUpdated函数。|\n|UTPawn | | | WeaponFired()函数 |\n\n上表描述便是主要的UTGame开火流程。\nPS：关于子弹Projectile：\nProjectile的物理相关属性中，bCollideWord被设为true（表示物体是否与关卡几何（CSG）发生collide。），因此，击中关卡中的物体的时候，会调用HitWall事件，进而调用TakeDamage()函数。\n\n居然吐着血，耐着markdown难用的表格写下来了。。。","slug":"UTGame武器开火流程","published":1,"updated":"2016-11-26T12:34:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cixlvoa2x0007jtu3urx66tdp","content":"<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">执行的对象</th>\n<th style=\"text-align:left\">本地客户端</th>\n<th style=\"text-align:left\">Server</th>\n<th style=\"text-align:center\">其他玩家客户端</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">playerController</td>\n<td style=\"text-align:left\">StartFire()</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">UTPawn</td>\n<td style=\"text-align:left\">StartFire()</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Weapon(LinkGun)</td>\n<td style=\"text-align:left\">StartFire()<br>StartFire主要做了两件事：<br>1. 本地直接执行BeginFire()<br>2. 如果是网络游戏会远程调用ServerStartFire()</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Weapon(LinkGun)</td>\n<td style=\"text-align:left\">BeginFire()<br>注意，此时Weapon的状态是Active，执行的是状态机里面的BeginFire()函数。<br>这里主要做了两件事：<br>1. 调用Global.BeginFire()。<br>这个函数调用了SetPendingFire()，而转而调用了InventoryManager的SetPendingFire()，这个函数只有一行代码：PendingFire[InFiringMode] = 1;将这个值设为1，主要是用来记录开火模式，鼠标左右键有不同开火模式。<br>2. 如果能开火，调用SendToFiringState()。<br>这个函数设置了开火模式（UTPawn的SetFiringMode()函数），然后跳转到开火状态WeaponFiring。<br>3. UTWeapon重写了这个BeginFire，并加入了checkRoom()功能，主要用在狙击枪开镜，这里不展开了，其实就是修改FOV视角。</td>\n<td style=\"text-align:left\">ServerStartFire()<br>主要是做了一件事：<br>执行BeginFire()。与本地客户端相同。</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Weapon(LinkGun)</td>\n<td style=\"text-align:left\">进入WeaponFiring状态，执行BeginState()。<br>这个函数做了两件事：<br>1. FireAmmunition()<br>这个函数也是干了两件事<br>（1)ConsumeAmmo()<br>消耗子弹。<br>（2）根据子弹类型调用不同逻辑，在这里以EWFT_Projectile为例，则执行ProjectileFire()。<br>ProjectileFire()主要做两件事：<br>  IncrementFlashCount()<br>     这个函数调用了UTPawn的IncrementFlashCount()函数。后面两行继续详细分析。<br> - 因为是客户端，所以不会执行这件事。（Spawn子弹）。<br>2. TimeWeaponFiring()<br>这个函数是两次开枪时间间隔相关的计时。</td>\n<td style=\"text-align:left\">1. 这里与本地客户端唯一区别就是ProjectileFire()函数，服务器还会做一件事情就是：创建子弹。<br>2. 创建子弹流程如下：<br>a) 调用Instigator的GetWeaponStartTraceLocation函数。如果Instigator有controller，这函数会返回controller的location，不然就返回它自己眼睛的位置，StartTrace。<br>b)    获得发射方向。GetAdjustedAim函数是一系列让weapon, the pawn and the controller调整子弹发射方向的处理的开始。它调用 了Pawn(如果有)的GetAdjustedAimFor()，然后调用AddSpread()增加散射调整后return最终的角度。Pawn的GetAdjustedAimFor()。<br>如果Pawn没有controller，则返回GetBaseAimRotation()的计算结果，否则调用controller的GetAdjustedAimFor()，让controller调整角度。<br>c)   调用GetPhysicalFireStartLoc()获得子弹的创建位置（一般是枪口位置）<br>d) 如果子弹创建位置和StartTrace不相等，那么需要根据用StartTrace、发射方向、射程来做射线检测，预测子弹的碰撞，CalcWeaponFire()，据碰撞点和子弹创建位置求得新的发射方向。<br>e)  Spawn子弹并init。</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">UTPawn</td>\n<td style=\"text-align:left\">IncrementFlashCount()<br>这个函数修改了FlashCount，再次设置SetFiringMode()保证开火模式正确，然后执行FlashCountUpdated()函数，FlashCountUpdated()函数会判断FlashCount，如果FlashCount&gt;0，那么执行WeaponFired()，否则WeaponStoppedFiring()。</td>\n<td style=\"text-align:left\">逻辑和本地客户端一样。<br>此外，因为FlashCount这个值是repnotify修饰的，所以会复制到其他客户端。</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">UTPawn</td>\n<td style=\"text-align:left\">WeaponFired()<br>这个函数主要是利用WeaponAttachment播放开火特效、角色动画、音效等。</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:center\">FlashCount的改变被复制下来，并执行ReplicatedEvent，这个函数内这时会根据参数名调用FlashCountUpdated函数。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">UTPawn</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:center\">WeaponFired()函数</td>\n</tr>\n</tbody>\n</table>\n<p>上表描述便是主要的UTGame开火流程。<br>PS：关于子弹Projectile：<br>Projectile的物理相关属性中，bCollideWord被设为true（表示物体是否与关卡几何（CSG）发生collide。），因此，击中关卡中的物体的时候，会调用HitWall事件，进而调用TakeDamage()函数。</p>\n<p>居然吐着血，耐着markdown难用的表格写下来了。。。</p>\n","excerpt":"","more":"<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">执行的对象</th>\n<th style=\"text-align:left\">本地客户端</th>\n<th style=\"text-align:left\">Server</th>\n<th style=\"text-align:center\">其他玩家客户端</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">playerController</td>\n<td style=\"text-align:left\">StartFire()</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">UTPawn</td>\n<td style=\"text-align:left\">StartFire()</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Weapon(LinkGun)</td>\n<td style=\"text-align:left\">StartFire()<br>StartFire主要做了两件事：<br>1. 本地直接执行BeginFire()<br>2. 如果是网络游戏会远程调用ServerStartFire()</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Weapon(LinkGun)</td>\n<td style=\"text-align:left\">BeginFire()<br>注意，此时Weapon的状态是Active，执行的是状态机里面的BeginFire()函数。<br>这里主要做了两件事：<br>1. 调用Global.BeginFire()。<br>这个函数调用了SetPendingFire()，而转而调用了InventoryManager的SetPendingFire()，这个函数只有一行代码：PendingFire[InFiringMode] = 1;将这个值设为1，主要是用来记录开火模式，鼠标左右键有不同开火模式。<br>2. 如果能开火，调用SendToFiringState()。<br>这个函数设置了开火模式（UTPawn的SetFiringMode()函数），然后跳转到开火状态WeaponFiring。<br>3. UTWeapon重写了这个BeginFire，并加入了checkRoom()功能，主要用在狙击枪开镜，这里不展开了，其实就是修改FOV视角。</td>\n<td style=\"text-align:left\">ServerStartFire()<br>主要是做了一件事：<br>执行BeginFire()。与本地客户端相同。</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Weapon(LinkGun)</td>\n<td style=\"text-align:left\">进入WeaponFiring状态，执行BeginState()。<br>这个函数做了两件事：<br>1. FireAmmunition()<br>这个函数也是干了两件事<br>（1)ConsumeAmmo()<br>消耗子弹。<br>（2）根据子弹类型调用不同逻辑，在这里以EWFT_Projectile为例，则执行ProjectileFire()。<br>ProjectileFire()主要做两件事：<br>  IncrementFlashCount()<br>     这个函数调用了UTPawn的IncrementFlashCount()函数。后面两行继续详细分析。<br> - 因为是客户端，所以不会执行这件事。（Spawn子弹）。<br>2. TimeWeaponFiring()<br>这个函数是两次开枪时间间隔相关的计时。</td>\n<td style=\"text-align:left\">1. 这里与本地客户端唯一区别就是ProjectileFire()函数，服务器还会做一件事情就是：创建子弹。<br>2. 创建子弹流程如下：<br>a) 调用Instigator的GetWeaponStartTraceLocation函数。如果Instigator有controller，这函数会返回controller的location，不然就返回它自己眼睛的位置，StartTrace。<br>b)    获得发射方向。GetAdjustedAim函数是一系列让weapon, the pawn and the controller调整子弹发射方向的处理的开始。它调用 了Pawn(如果有)的GetAdjustedAimFor()，然后调用AddSpread()增加散射调整后return最终的角度。Pawn的GetAdjustedAimFor()。<br>如果Pawn没有controller，则返回GetBaseAimRotation()的计算结果，否则调用controller的GetAdjustedAimFor()，让controller调整角度。<br>c)   调用GetPhysicalFireStartLoc()获得子弹的创建位置（一般是枪口位置）<br>d) 如果子弹创建位置和StartTrace不相等，那么需要根据用StartTrace、发射方向、射程来做射线检测，预测子弹的碰撞，CalcWeaponFire()，据碰撞点和子弹创建位置求得新的发射方向。<br>e)  Spawn子弹并init。</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">UTPawn</td>\n<td style=\"text-align:left\">IncrementFlashCount()<br>这个函数修改了FlashCount，再次设置SetFiringMode()保证开火模式正确，然后执行FlashCountUpdated()函数，FlashCountUpdated()函数会判断FlashCount，如果FlashCount&gt;0，那么执行WeaponFired()，否则WeaponStoppedFiring()。</td>\n<td style=\"text-align:left\">逻辑和本地客户端一样。<br>此外，因为FlashCount这个值是repnotify修饰的，所以会复制到其他客户端。</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">UTPawn</td>\n<td style=\"text-align:left\">WeaponFired()<br>这个函数主要是利用WeaponAttachment播放开火特效、角色动画、音效等。</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:center\">FlashCount的改变被复制下来，并执行ReplicatedEvent，这个函数内这时会根据参数名调用FlashCountUpdated函数。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">UTPawn</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:center\">WeaponFired()函数</td>\n</tr>\n</tbody>\n</table>\n<p>上表描述便是主要的UTGame开火流程。<br>PS：关于子弹Projectile：<br>Projectile的物理相关属性中，bCollideWord被设为true（表示物体是否与关卡几何（CSG）发生collide。），因此，击中关卡中的物体的时候，会调用HitWall事件，进而调用TakeDamage()函数。</p>\n<p>居然吐着血，耐着markdown难用的表格写下来了。。。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cixlvoa2f0000jtu3c5qaw5g7","category_id":"cixlvoa2m0003jtu3dxvltl98","_id":"cixlvoa2z000ajtu3y6hmlzqk"},{"post_id":"cixlvoa2k0002jtu3hbq3it38","category_id":"cixlvoa2y0008jtu3v378hnww","_id":"cixlvoa31000cjtu3vwgpn7b6"},{"post_id":"cixlvoa2r0005jtu3sqgmvxaq","category_id":"cixlvoa2y0008jtu3v378hnww","_id":"cixlvoa31000ejtu3iw66juav"},{"post_id":"cixlvoa2v0006jtu3ugpuoiot","category_id":"cixlvoa31000djtu3kp1vrtdx","_id":"cixlvoa32000gjtu3eje3o9dl"},{"post_id":"cixlvoa2x0007jtu3urx66tdp","category_id":"cixlvoa2y0008jtu3v378hnww","_id":"cixlvoa33000hjtu3tpgie50y"}],"PostTag":[{"post_id":"cixlvoa2f0000jtu3c5qaw5g7","tag_id":"cixlvoa2q0004jtu31g6xwgj3","_id":"cixlvoa2y0009jtu3b3ugazfl"}],"Tag":[{"name":"OpenGL ES","_id":"cixlvoa2q0004jtu31g6xwgj3"}]}}